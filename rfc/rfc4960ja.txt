1.はじめに 

このセクションでは、Stream Control Transmission Protocol（SCTP）の開発の背後にある理由、それが提供するサービス、およびプロトコルの詳細な説明を理解するために必要な基本概念について説明します.  

このドキュメントは、[RFC2960]と[RFC3309]を廃止します.  

1.1. 動機

TCP [RFC0793]は、IPネットワークでの信頼できるデータ転送の主要な手段として、膨大なサービスを実行しました. ただし、最近のアプリケーションの増加により、TCPの制限が厳しすぎることがわかり、UDP [RFC0768]の上に独自の信頼できるデータ転送プロトコルが組み込まれています. ユーザーがバイパスしたい制限には、次のものがあります. 

-TCPは、信頼性の高いデータ転送と厳密な送信順序のデータ配信の両方を提供します. シーケンスメンテナンスなしで信頼性の高い転送が必要なアプリケーションもあれば、データの部分的な順序付けで満足できるアプリケーションもあります. どちらの場合も、TCPによって提供される行頭ブロッキングにより、不必要な遅延が発生します. 

-TCPのストリーム指向の性質は、しばしば不便です. アプリケーションは、独自のレコードマーキングを追加してメッセージの輪郭を描き、プッシュ機能を明示的に使用して、適切な時間内に完全なメッセージが転送されるようにする必要があります. 

-TCPソケットの範囲が限られているため、マルチホームホストを使用した高可用性データ転送機能を提供するタスクが複雑になります.  

-TCPは、SYN攻撃などのDoS攻撃に対して比較的脆弱です.  

IPネットワークを介したPSTNシグナリングの転送は、TCPのこれらの制限すべてが関連するアプリケーションです. このアプリケーションはSCTPの開発を直接動機付けましたが、他のアプリケーションはSCTPがそれらの要件にぴったりであることがわかります. 

1.2. SCTPのアーキテクチャビュー

SCTPは、SCTPユーザーアプリケーション（略して「SCTPユーザー」）とIPなどのコネクションレスパケットネットワークサービスとの間のレイヤーと見なされます. このドキュメントの残りの部分では、SCTPがIP上で実行されることを前提としています. SCTPが提供する基本的なサービスは、ピアSCTPユーザー間のユーザーメッセージの信頼できる転送です. このサービスは、2つのSCTPエンドポイント間の関連付けのコンテキスト内で実行されます. このドキュメントのセクション10では、SCTPとSCTPユーザーレイヤーの境界に存在する必要があるAPIをスケッチしています. 

SCTPは本質的に接続指向ですが、SCTPアソシエーションはTCP接続よりも広い概念です. SCTPは、各SCTPエンドポイント（1.3節）が他のエンドポイント（アソシエーションの起動中）にトランスポートアドレスのリスト（つまり、SCTPポートと組み合わせた複数のIPアドレス）を提供する手段を提供します.  SCTPパケットを発信します. この関連付けは、各エンドポイントのリストから生成される可能性のあるすべてのソース/宛先の組み合わせを介して転送にまたがります. 

       _____________                                      _____________
      |  SCTP User  |                                    |  SCTP User  |
      | Application |                                    | Application |
      |-------------|                                    |-------------|
      |    SCTP     |                                    |    SCTP     |
      |  Transport  |                                    |  Transport  |
      |   Service   |                                    |   Service   |
      |-------------|                                    |-------------|
      |             |One or more    ----      One or more|             |
      | IP Network  |IP address      \/        IP address| IP Network  |
      |   Service   |appearances     /\       appearances|   Service   |
      |_____________|               ----                 |_____________|

        SCTP Node A |<-------- Network transport ------->| SCTP Node B

図1：SCTPアソシエーション 

1.3. 主な用語

SCTPの説明に使用される言語の一部は、前のセクションで紹介されています. このセクションでは、主要な用語とその定義の統合リストを提供します. 

oアクティブな宛先トランスポートアドレス：ピアエンドポイント上のトランスポートアドレス. 送信エンドポイントはユーザーメッセージの受信に使用可能と見なします.  

oバンドリング：オプションの多重化操作. これにより、複数のユーザーメッセージを同じSCTPパケットで伝送できます. 各ユーザーメッセージは、独自のDATAチャンクを占有します. 

oチャンク：SCTPパケット内の情報の単位. チャンクヘッダーとチャンク固有のコンテンツで構成されます.  

o輻輳ウィンドウ（cwnd）：送信者が確認応答を受信する前に特定の宛先トランスポートアドレスに送信できるデータをバイト数で制限するSCTP変数.  

o累積TSN確認ポイント：SACKの累積TSN確認フィールドを介して確認された最後のDATAチャンクのTSN.  

oアイドル宛先アドレス：一定時間内にユーザーメッセージが送信されなかったアドレス. 通常はHEARTBEAT間隔以上.  

o非アクティブな宛先トランスポートアドレス：エラーのために非アクティブと見なされ、ユーザーメッセージをトランスポートできないアドレス.  

oメッセージ=ユーザーメッセージ：上位層プロトコル（ULP）によってSCTPに送信されたデータ.  

oメッセージ認証コード（MAC）：秘密鍵を使用した暗号化ハッシュ関数に基づく整合性チェックメカニズム. 通常、メッセージ認証コードは、秘密鍵を共有する2つのパーティ間で使用され、これらのパーティ間で送信される情報を検証します. SCTPでは、COOKIE ECHOチャンクでピアから返される状態Cookie情報を検証するためにエンドポイントによって使用されます. 「MAC」という用語は、コンテキストによって意味が異なります. SCTPは、この用語を[RFC2104]と同じ意味で使用します. 

oネットワークバイトオーダー：最上位バイト、つまりビッグエンディアン.  

o順序付けられたメッセージ：メッセージが送信されたストリーム内で送信された以前のすべてのユーザーメッセージに関して順番に配信されるユーザーメッセージ.  

o優れたTSN（SCTPエンドポイント）：エンドポイントによって送信されたが、まだ確認応答を受信して​​いないTSN（および関連するDATAチャンク）.  

oパス：1つのSCTPエンドポイントによってピアSCTPエンドポイントの特定の宛先トランスポートアドレスに送信されたSCTPパケットがたどるルート. 異なる宛先トランスポートアドレスに送信しても、必ずしも個別のパスを取得できるとは限りません. 

oプライマリパス：プライマリパスは、デフォルトでピアエンドポイントへのアウトバウンドパケットに入れられる宛先およびソースアドレスです. 実装は、宛先と送信元アドレスの両方を指定して、応答チャンクとデータ送信者がマルチホームになっているときにパケットが送信されるインターフェイスをより適切に制御したい場合があるため、定義には送信元アドレスが含まれます. 

o受信ウィンドウ（rwnd）：データ送信側が、ピアの最新の計算された受信ウィンドウをバイト数で保存するために使用するSCTP変数. これにより、送信者は、受信者のインバウンドバッファで使用可能なスペースを示します. 

o SCTPアソシエーション：2つのSCTPエンドポイントと検証タグや現在アクティブな伝送シーケンス番号（TSN）などのプロトコル状態情報で構成されるSCTPエンドポイント間のプロトコル関係. アソシエーションは、使用されるトランスポートアドレスによって一意に識別できます. 関連付けのエンドポイントによって. 2つのSCTPエンドポイントは、常にそれらの間に複数のSCTPアソシエーションを持つことはできません. 

o SCTPエンドポイント：SCTPパケットの論理的な送信者/受信者. マルチホームホストでは、SCTPエンドポイントは、SCTPパケットを送信できる適格な宛先トランスポートアドレスのセットと、SCTPパケットを受信できる適格なソーストランスポートアドレスの組み合わせのピアとして表されます. SCTPエンドポイントで使用されるすべてのトランスポートアドレスは同じポート番号を使用する必要がありますが、複数のIPアドレスを使用できます. SCTPエンドポイントで使用されるトランスポートアドレスは、別のSCTPエンドポイントで使用しないでください. つまり、トランスポートアドレスはSCTPエンドポイントに固有です. 

o SCTPパケット（またはパケット）：SCTPとコネクションレスパケットネットワーク（IPなど）間のインターフェイスを介したデータ配信の単位. SCTPパケットには、共通のSCTPヘッダー、可能なSCTP制御チャンク、およびSCTP DATAチャンク内にカプセル化されたユーザーデータが含まれます. 

o SCTPユーザーアプリケーション（SCTPユーザー）：SCTPのサービスを使用する論理的な上位層のアプリケーションエンティティ. 上位層プロトコル（ULP）とも呼ばれます.  

oスロースタートしきい値（ssthresh）：SCTP変数. これは、エンドポイントが特定の宛先トランスポートアドレスでスロースタートまたは輻輳回避を実行するかどうかを決定するために使用するしきい値です. Ssthreshはバイト数です. 

oストリーム：順不同の配信サービスに送信されたものを除くすべてのユーザーメッセージが順番に配信される、1つの別の関連SCTPエンドポイントから確立された単方向論理チャネル.  

注：反対方向のストリーム番号間の関係は、厳密にアプリケーションがそれらを使用する方法の問題です. これらの相関関係が必要な場合は、SCTPユーザーの責任で作成および管理してください. 

oストリームシーケンス番号：SCTPによって内部的に使用される16ビットのシーケンス番号は、特定のストリーム内でユーザーメッセージのシーケンス配信を保証します. 各ユーザーメッセージに1つのストリームシーケンス番号が添付されます. 

oタイタグ：一緒に64ビットのナンスを作る2つの32ビットの乱数. これらのタグは、状態CookieおよびTCB内で使用されるため、新たに再起動する関連付けは、再起動せずに既存の関連付けの真の検証タグを明らかにしないエンドポイント内の元の関連付けにリンクできます. 

o Transmission Control Block（TCB）：他のSCTPエンドポイントへの既存のSCTPアソシエーションごとにSCTPエンドポイントによって作成された内部データ構造. TCBには、対応する関連付けを維持および管理するためのエンドポイントのすべてのステータスおよび操作情報が含まれています. 

o Transmission Sequence Number（TSN）：SCTPによって内部的に使用される32ビットのシーケンス番号. ユーザーデータを含む各チャンクに1つのTSNが添付され、受信SCTPエンドポイントが受信を確認し、重複した配信を検出できるようにします. 

oトランスポートアドレス：トランスポートアドレスは、従来、ネットワーク層アドレス、トランスポート層プロトコル、およびトランスポート層ポート番号によって定義されています. IP上で実行されているSCTPの場合、トランスポートアドレスは、IPアドレスとSCTPポート番号の組み合わせによって定義されます（SCTPはトランスポートプロトコルです）. 

o未承認TSN（SCTPエンドポイント）：エンドポイントによって受信されたが、確認応答がまだ送信されていないTSN（および関連するDATAチャンク）. または、反対の場合、送信されたが確認応答が受信されていないパケットの場合. o順序付けられていないメッセージ：順序付けられていないメッセージは、他のメッセージに対して「順序付けられていない」. これには、他の順序付けされていないメッセージと他の順序付けされたメッセージの両方が含まれます. 順序付けされていないメッセージは、同じストリームで送信される順序付けされたメッセージの前または後に配信される場合があります. 

oユーザーメッセージ：SCTPとそのユーザー間のインターフェイスを介したデータ配信の単位.  

o検証タグ：ランダムに生成される32ビットの符号なし整数. 検証タグは、SCTPパケットが現在のアソシエーションに属し、以前のアソシエーションからの古いまたは古いパケットではないことを受信者が検証できるようにするキーを提供します. 

1.4. 略語

MAC-メッセージ認証コード[RFC2104] 

RTO-再送信タイムアウト 

RTT-往復時間 

RTTVAR-往復時間の変動 

SCTP-ストリーム制御伝送プロトコル 

SRTT-平滑化されたRTT 

TCB-伝送制御ブロック 

TLV-Type-Length-Valueコーディング形式 

TSN-送信シーケンス番号 

ULP-上位プロトコル 

1.5. SCTPの機能ビュー

SCTPトランスポートサービスは、いくつかの機能に分解できます. これらを図2に示し、このセクションの残りの部分で説明します. 

SCTPユーザーアプリケーション

            -----------------------------------------------------
             _____________                  ____________________
            |             |                | Sequenced Delivery |
            | Association |                |   within Streams   |
            |             |                |____________________|
            |   Startup   |
            |             |         ____________________________
            |     and     |        |    User Data Fragmentation |
            |             |        |____________________________|
            |   Takedown  |
            |             |         ____________________________
            |             |        |     Acknowledgement        |
            |             |        |          and               |
            |             |        |    Congestion Avoidance    |
            |             |        |____________________________|
            |             |
            |             |         ____________________________
            |             |        |       Chunk Bundling       |
            |             |        |____________________________|
            |             |
            |             |     ________________________________
            |             |    |      Packet Validation         |
            |             |    |________________________________|
            |             |
            |             |     ________________________________
            |             |    |     Path Management            |
            |_____________|    |________________________________|

図2：SCTPトランスポートサービスの機能ビュー 

1.5.1. アソシエーションの起動と削除

関連付けは、SCTPユーザーからの要求によって開始されます（セクション10のASSOCIATE（またはSEND）プリミティブの説明を参照）.  

[RFC2522]でKarnとSimpsonによって説明されたものと同様のCookieメカニズムが、同期攻撃に対する保護を提供するために初期化中に使用されます. Cookieメカニズムは、4方向ハンドシェイクを使用します. 最後の2つのレッグは、高速セットアップのためにユーザーデータを運ぶことができます. 起動シーケンスについては、このドキュメントのセクション5で説明しています. 

SCTPは、SCTPユーザーからの要求に応じて、アクティブなアソシエーションのグレースフルクローズ（シャットダウン）を提供します. セクション10のSHUTDOWNプリミティブの説明を参照してください. SCTPでは、ユーザーからの要求（ABORTプリミティブ）、またはSCTPレイヤー内で検出されたエラー状態の結果として、グレースフルクローズ（アボート）も許可します. セクション9では、グレースフルクローズ手順とアングレースフルクローズ手順の両方について説明します. 

SCTPは、片方がデータを送信し続ける一方で、もう一方の端が閉じられるような半開状態（TCPなど）をサポートしません. いずれかのエンドポイントがシャットダウンを実行すると、各ピアの関連付けはユーザーからの新しいデータの受け入れを停止し、グレースフルクローズ時にキュー内のデータのみを配信します（セクション9を参照）. 

1.5.2. Streams内のシーケンス配信

「ストリーム」という用語はSCTPで使用され、同じストリーム内の他のメッセージに関して上位層プロトコルに順番に配信されるユーザーメッセージのシーケンスを指します. これは、TCPでの使用とは対照的です. TCPでは、バイトのシーケンスを参照します（このドキュメントでは、バイトは8ビットと想定されています）. 

SCTPユーザーは、関連付けの起動時に、関連付けによってサポートされるストリームの数を指定できます. この番号は、リモートエンドとネゴシエートされます（セクション5.1.1を参照）. ユーザーメッセージは、ストリーム番号（SEND、RECEIVEプリミティブ、セクション10）に関連付けられています. 内部的に、SCTPはSCTPユーザーによって渡された各メッセージにストリームシーケンス番号を割り当てます. 受信側では、SCTPは、指定されたストリーム内でメッセージが順番にSCTPユーザーに配信されるようにします. ただし、1つのストリームが次の順序どおりのユーザーメッセージを待ってブロックされている間は、他のストリームからの配信が続行される場合があります. 

SCTPは、シーケンス配信サービスをバイパスするメカニズムを提供します. このメカニズムを使用して送信されたユーザーメッセージは、受信するとすぐにSCTPユーザーに配信されます. 

1.5.3. ユーザーデータの断片化

必要に応じて、SCTPはユーザーメッセージを断片化し、下位層に渡されるSCTPパケットがパスMTUに準拠するようにします. 受信すると、フラグメントはSCTPユーザーに渡される前に完全なメッセージに再構成されます. 

1.5.4. 承認と輻輳回避

SCTPは、各ユーザーデータフラグメントまたはフラグメント化されていないメッセージにTransmission Sequence Number（TSN）を割り当てます. TSNは、ストリームレベルで割り当てられたストリームシーケンス番号とは無関係です. 受信側は、シーケンスにギャップがある場合でも、受信したすべてのTSNを確認します. このようにして、信頼性の高い配信は、シーケンス化されたストリーム配信と機能的に分離されます. 確認応答および輻輳回避機能は、タイムリーな確認応答が受信されなかった場合のパケットの再送信を担当します. パケットの再送信は、TCPに使用されるものと同様の輻輳回避手順によって条件付けられます. この機能に関連するプロトコル手順の詳細については、セクション6およびセクション7を参照してください. 

1.5.5. チャンクバンドリング

セクション3で説明したように、下位層に配信されるSCTPパケットは、1つ以上のチャンクが後に続く共通ヘッダーで構成されます. 各チャンクには、ユーザーデータまたはSCTP制御情報のいずれかが含まれます. SCTPユーザーには、複数のユーザーメッセージを1つのSCTPパケットにまとめることを要求するオプションがあります. SCTPのチャンクバンドリング機能は、完全なSCTPパケットのアセンブリと、受信側でのその逆アセンブリを担当します. 

輻輳時には、ユーザーがSCTPをバンドルしないように要求した場合でも、SCTP実装はバンドリングを実行する場合があります. ユーザーによるバンドリングの無効化は、SCTPの実装にのみ影響します. SCTPの実装は、送信前にわずかな時間を遅らせる可能性があります（バンドリングを促進するため）. ユーザー層がバンドリングを無効にすると、この小さな遅延は禁止されますが、輻輳または再送信中に実行されるバンドリングは禁止されます. 

1.5.6. パケット検証

必須の検証タグフィールドと32ビットチェックサムフィールド（CRC32cチェックサムの説明については付録Bを参照）がSCTP共通ヘッダーに含まれています. 検証タグの値は、関連付けの起動時に関連付けの各端によって選択されます. 予期される検証タグ値なしで受信されたパケットは、ブラインドマスカレード攻撃および以前のアソシエーションからの古いSCTPパケットに対する保護として、破棄されます. CRC32cチェックサムは、ネットワーク内のデータ破損に対する追加の保護を提供するために、各SCTPパケットの送信者が設定する必要があります. 無効なCRC32cチェックサムを持つSCTPパケットの受信者は、パケットを静かに破棄します. 

1.5.7. パス管理

送信SCTPユーザーは、セクション10で説明したプリミティブを介して、SCTPパケットの宛先として使用されるトランスポートアドレスのセットを操作できます. SCTPパス管理機能は、SCTPユーザーの指示と適格な宛先セットの現在認識されている到達可能性ステータス. パス管理機能は、他のパケットトラフィックがこの情報を提供するのに不十分な場合、ハートビートを介して到達可能性を監視し、遠端のトランスポートアドレスの到達可能性が変更されたときにSCTPユーザーに通知します. パス管理機能は、アソシエーションの起動中にローカルトランスポートアドレスの適格なセットを遠端に報告し、遠端から返されたトランスポートアドレスをSCTPユーザーに報告する役割も担います. 

アソシエーションの起動時に、SCTPエンドポイントごとにプライマリパスが定義され、SCTPパケットの通常の送信に使用されます.  

受信側では、パス管理は受信SCTPパケットが属する有効なSCTPアソシエーションの存在を確認してから、さらに処理するためにそれを渡します.  

注：パス管理とパケット検証は同時に行われるため、上記で個別に説明していますが、実際には個別の項目として実行することはできません.  

1.6. シリアル番号演算

実際の送信シーケンス番号スペースは非常に大きいものの、有限であることに注意する必要があります. このスペースの範囲は0〜2 ** 32-1です. スペースは有限であるため、伝送シーケンス番号を扱うすべての算術演算は2 ** 32を法として実行する必要があります. この符号なし算術は、シーケンス番号が2 ** 32-1から0に再び循環するときに、シーケンス番号の関係を保持します. コンピューターのモジュロ演算には微妙な点があるため、このような値の比較のプログラミングには細心の注意を払う必要があります. TSNを指す場合、記号「= <」は「以下」を意味します（モジュロ2 ** 32）. 

このドキュメントのTSNでの比較と算術は、[RFC1982]で定義されているシリアル番号算術を使用する必要があります（SERIAL_BITS = 32）.  

エンドポイントは、現在の送信ウィンドウの開始TSNより2 ** 31-1以上大きいTSNを持つDATAチャンクを送信すべきではありません. これを行うと、TSNの比較で問題が発生します. 

送信シーケンス番号は、2 ** 32-1に達するとラップアラウンドします. つまり、TSN = 2 * 32-1を送信した後、DATAチャンクが使用する次のTSNはTSN = 0です.  

ストリームシーケンス番号で行われる算術は、[RFC1982]で定義されているシリアル番号算術を使用する必要があります（SERIAL_BITS = 16）. このドキュメントの他のすべての算術および比較では、通常の算術を使用します.  

1.7. RFC 2960からの変更

SCTPはもともと[RFC2960]で定義されていましたが、このドキュメントでは廃止されました. このドキュメントに組み込まれているさまざまな変更の詳細に興味のある読者は、[RFC4460]に相談するように求められます. 

2.コンベンション 

このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」はRFC 2119 [RFC2119]で説明されているように解釈されます.  

3. SCTPパケット形式 

SCTPパケットは、共通のヘッダーとチャンクで構成されます. チャンクには、制御情報またはユーザーデータのいずれかが含まれます. 

SCTPパケット形式は次のとおりです.  

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                        Common Header                          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                          Chunk #1                             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           ...                                 |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                          Chunk #n                             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

INIT、INIT ACK、およびSHUTDOWN COMPLETEチャンクを除き、MTUサイズまで複数のチャンクを1つのSCTPパケットにバンドルできます. これらのチャンクは、パケット内の他のチャンクとバンドルしてはいけません. チャンクバンドリングの詳細については、セクション6.10を参照してください. 

ユーザーデータメッセージが1つのSCTPパケットに収まらない場合、セクション6.9で定義されている手順を使用して、複数のチャンクにフラグメント化できます.  

特に明記しない限り、SCTPパケットのすべての整数フィールドはネットワークバイト順で送信する必要があります.  

3.1. SCTP共通ヘッダーフィールドの説明

SCTP共通ヘッダー形式 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |     Source Port Number        |     Destination Port Number   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      Verification Tag                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           Checksum                            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

送信元ポート番号：16ビット（符号なし整数） 

これはSCTP送信者のポート番号です. 受信者は、送信元IPアドレス、SCTP宛先ポート、および場合によっては宛先IPアドレスと組み合わせて使用​​して、このパケットが属するアソシエーションを識別することができます. ポート番号0は使用しないでください. 

宛先ポート番号：16ビット（符号なし整数） 

これは、このパケットの宛先となるSCTPポート番号です. 受信ホストはこのポート番号を使用して、正しい受信エンドポイント/アプリケーションへのSCTPパケットを逆多重化します. ポート番号0は使用しないでください. 

検証タグ：32ビット（符号なし整数） 

このパケットの受信者は検証タグを使用して、このSCTPパケットの送信者を検証します. 送信時には、この検証タグの値を、関連付けの初期化中にピアエンドポイントから受信した開始タグの値に設定する必要がありますが、次の例外があります. 

-INITチャンクを含むパケットには、検証タグがゼロでなければなりません.  

-Tビットが設定されたSHUTDOWN COMPLETEチャンクを含むパケットには、SHUTDOWN ACKチャンクを持つパケットから検証タグをコピーする必要があります.  

-ABORTチャンクを含むパケットには、ABORTを送信したパケットから検証タグがコピーされている場合があります. 詳細については、セクション8.4およびセクション8.5を参照してください. 

INITチャンクは、それを運ぶSCTPパケットの唯一のチャンクでなければなりません.  

チェックサム：32ビット（符号なし整数） 

このフィールドには、このSCTPパケットのチェックサムが含まれます. その計算については、セクション6.8で説明します. SCTPは、チェックサムの計算に付録Bで説明されているCRC32cアルゴリズムを使用します. 

3.2. チャンクフィールドの説明

以下の図は、SCTPパケットで送信されるチャンクのフィールド形式を示しています. 各チャンクは、チャンクタイプフィールド、チャンク固有のフラグフィールド、チャンク長フィールド、および値フィールドでフォーマットされます. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Chunk Type  | Chunk  Flags  |        Chunk Length           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       \                                                               \
       /                          Chunk Value                          /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

チャンクタイプ：8ビット（符号なし整数） 

このフィールドは、「チャンク値」フィールドに含まれる情報のタイプを識別します. 0から254の値を取ります. 255の値は、拡張フィールドとして将来使用するために予約されています. 

チャンクタイプの値は次のように定義されます.  

   ID Value    Chunk Type
   -----       ----------
   0          - Payload Data (DATA)
   1          - Initiation (INIT)
   2          - Initiation Acknowledgement (INIT ACK)
   3          - Selective Acknowledgement (SACK)
   4          - Heartbeat Request (HEARTBEAT)
   5          - Heartbeat Acknowledgement (HEARTBEAT ACK)
   6          - Abort (ABORT)
   7          - Shutdown (SHUTDOWN)
   8          - Shutdown Acknowledgement (SHUTDOWN ACK)
   9          - Operation Error (ERROR)
   10         - State Cookie (COOKIE ECHO)
   11         - Cookie Acknowledgement (COOKIE ACK)
   12         - Reserved for Explicit Congestion Notification Echo
                (ECNE)
   13         - Reserved for Congestion Window Reduced (CWR)
   14         - Shutdown Complete (SHUTDOWN COMPLETE)
   15 to 62   - available
   63         - reserved for IETF-defined Chunk Extensions
   64 to 126  - available
   127        - reserved for IETF-defined Chunk Extensions
   128 to 190 - available
   191        - reserved for IETF-defined Chunk Extensions
   192 to 254 - available
   255        - reserved for IETF-defined Chunk Extensions

チャンクタイプは、処理エンドポイントがチャンクタイプを認識しない場合に実行する必要があるアクションを最上位2ビットで指定するようにエンコードされます.  

00-このSCTPパケットの処理を停止して破棄します. それ以上のチャンクは処理しません.  

01-このSCTPパケットの処理を停止して破棄し、その中のそれ以上のチャンクを処理せず、「認識されないチャンクタイプ」で認識されないチャンクを報告します.  

10-このチャンクをスキップして処理を続行します.  

11-このチャンクをスキップして処理を続行しますが、エラーの原因として「認識されないチャンクタイプ」を使用してERRORチャンクで報告します.  

注：ECNEおよびCWRチャンクタイプは、明示的輻輳通知（ECN）の将来の使用のために予約されています. 付録Aを参照してください. 

チャンクフラグ：8ビット 

これらのビットの使用法は、[チャンクタイプ]フィールドで指定されたチャンクタイプによって異なります. 特に指定がない限り、送信時に0に設定され、受信時には無視されます. 

チャンク長：16ビット（符号なし整数） 

この値は、チャンクタイプ、チャンクフラグ、チャンク長、およびチャンク値フィールドを含む、バイト単位でチャンクのサイズを表します. したがって、「チャンク値」フィールドの長さがゼロの場合、「長さ」フィールドは4に設定されます. 「チャンク長」フィールドは、チャンクの埋め込みをカウントしません. 

チャンク（タイプ、長さ、および値フィールドを含む）は、送信者によって4バイト長の倍数になるようにすべてゼロバイトが埋め込まれます. このパディングは、合計で3バイトを超えてはなりません. チャンク長の値には、チャンクの終端パディングは含まれません. ただし、チャンクの最後のパラメーターを除く可変長パラメーターのパディングは含まれます. 受信者はパディングを無視しなければなりません. 

注：堅牢な実装は、最終パディングがチャンク長に含まれているかどうかにかかわらず、チャンクを受け入れる必要があります.  

チャンク値：可変長 

チャンク値フィールドには、チャンクで転送される実際の情報が含まれています. このフィールドの使用法と形式は、チャンクタイプによって異なります. 

チャンクの合計の長さ（Type、Length、およびValueフィールドを含む）は4バイトの倍数でなければなりません. チャンクの長さが4バイトの倍数でない場合、送信者はチャンクにすべてゼロバイトをパディングする必要があり、このパディングはチャンク長フィールドに含まれません. 送信者は3バイトを超えてパディングしてはなりません. 受信者はパディングバイトを無視しなければなりません. 

SCTP定義のチャンクについては、セクション3.3で詳しく説明します. IETF定義のチャンク拡張のガイドラインは、このドキュメントのセクション14.1にあります. 

3.2.1. オプション/可変長パラメーター形式

SCTP制御チャンクのチャンク値は、必須フィールドのチャンクタイプ固有のヘッダーと、それに続くゼロ個以上のパラメーターで構成されます. チャンクに含まれるオプションの可変長パラメーターは、以下に示すように、Type-Length-Value形式で定義されます. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Parameter Type       |       Parameter Length        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       \                                                               \
       /                       Parameter Value                         /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

チャンクパラメータタイプ：16ビット（符号なし整数） 

Typeフィールドは、パラメーターのタイプの16ビットの識別子です. 0〜65534の値を取ります. 

65535の値は、IETF定義の拡張用に予約されています. 特定のSCTPチャンクの説明で定義されている値以外の値は、IETFで使用するために予約されています. 

チャンクパラメーターの長さ：16ビット（符号なし整数） 

[パラメータの長さ]フィールドには、パラメータタイプ、パラメータ長、およびパラメータ値フィールドを含む、パラメータのサイズがバイト単位で含まれています. したがって、長さゼロのパラメーター値フィールドを持つパラメーターの長さフィールドは4になります. パラメーター長には、パディングバイトは含まれません. 

チャンクパラメータ値：可変長 

[パラメーター値]フィールドには、パラメーターで転送される実際の情報が含まれています.  

パラメーターの全長（Type、Parameter Length、Valueフィールドを含む）は4バイトの倍数でなければなりません. パラメーターの長さが4バイトの倍数でない場合、送信者はパラメーターの最後（つまり、パラメーター値フィールドの後）にすべてゼロのバイトを埋め込みます. パディングの長さは、パラメーター長フィールドには含まれません. 送信者は3バイトを超えてパディングしてはなりません. 受信者はパディングバイトを無視しなければなりません. 

パラメータタイプは、処理エンドポイントがパラメータタイプを認識しない場合に実行する必要があるアクションを最上位2ビットで指定するようにエンコードされます.  

00-このパラメーターの処理を停止します. このチャンク内のそれ以上のパラメーターを処理しないでください. 

01-セクション3.2.2で説明されているように、このパラメーターの処理を停止し、このチャンク内のそれ以上のパラメーターを処理せず、「認識されないパラメーター」で認識されないパラメーターを報告します.  

10-このパラメーターをスキップして処理を続行します.  

11-このパラメーターをスキップして処理を続行しますが、セクション3.2.2で説明されているように、「認識されないパラメーター」で認識されないパラメーターを報告します.  

4つの場合すべてで、INIT ACKまたはCOOKIE ECHOチャンクが送信されることに注意してください. 00または01の場合、不明なパラメーターの後のパラメーターの処理はキャンセルされますが、すでに実行された処理はロールバックされません. 

実際のSCTPパラメーターは、特定のSCTPチャンクセクションで定義されます. IETF定義のパラメーター拡張のルールは、セクション14.2で定義されています. パラメータタイプはすべてのチャンクで一意でなければならないことに注意してください. たとえば、パラメータタイプ「5」はIPv4アドレスを表すために使用されます（セクション3.3.2.1を参照）. 次に、値「5」は、IPv4アドレスを表すためにすべてのチャンクにわたって予約されており、他のチャンクで異なる意味で再利用してはなりません. 

3.2.2. 認識されないパラメーターの報告

INITチャンクの受信者が認識されないパラメータを検出し、セクション3.2.1に従ってそれらを報告する必要がある場合、INITチャンクに応答して送信されるINIT ACKチャンクに「認識されないパラメータ」パラメータを配置する必要があります. INITチャンクの受信者がアソシエーションを確立しない場合（リソースの不足など）、INITの送信者に送信されるABORTには「認識されないパラメーター」が含まれないことに注意してください. 

INIT ACKチャンクの受信者が認識されないパラメータを検出し、セクション3.2.1に従ってそれらを報告する必要がある場合、「認識されないパラメータ」エラー原因を含むERRORチャンクを、INIT ACKチャンクに応答して送信されるCOOKIE ECHOチャンクにバンドルする必要があります. INIT ACKの受信者がCOOKIE ECHOチャンクをERRORチャンクにバンドルできない場合、ERRORチャンクは個別に送信できますが、COOKIE A​​CKが受信される前ではありません. 

注：COOKIE ECHOがパケットで送信されるときは常に、最初のチャンクでなければなりません.  

3.3. SCTPチャンクの定義

このセクションでは、さまざまなSCTPチャンクタイプの形式を定義します.  

3.3.1. ペイロードデータ（DATA）（0）

DATAチャンクには次の形式を使用する必要があります.  

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 0    | Reserved|U|B|E|    Length                     |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                              TSN                              |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |      Stream Identifier S      |   Stream Sequence Number n    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                  Payload Protocol Identifier                  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       \                                                               \
       /                 User Data (seq n of Stream S)                 /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

予約済み：5ビット 

すべて「0」に設定し、レシーバーで無視する必要があります.  

Uビット：1ビット 

（U）norderedビットは、「1」に設定されている場合、これが順序付けられていないDATAチャンクであり、このDATAチャンクに割り当てられたストリームシーケンス番号がないことを示します. したがって、受信者はStream Sequence Numberフィールドを無視しなければなりません. 

（必要に応じて）再構成後、順序変更されていないDATAチャンクは、順序変更を試みることなく、受信者によって上位層にディスパッチされなければなりません（MUST）.  

順序付けられていないユーザーメッセージが断片化されている場合、メッセージの各断片のUビットは「1」に設定されている必要があります.  

Bビット：1ビット 

（B）生成フラグメントビット（設定されている場合）は、ユーザーメッセージの最初のフラグメントを示します.  

Eビット：1ビット 

（E）ndingフラグメントビット（設定されている場合）は、ユーザーメッセージの最後のフラグメントを示します.  

断片化されていないユーザーメッセージには、BビットとEビットの両方が「1」に設定されている必要があります. BビットとEビットの両方を「0」に設定すると、次の表に要約されているように、マルチフラグメントユーザーメッセージの中間フラグメントが示されます. 


               B E                  Description
            ============================================================
            |  1 0 | First piece of a fragmented user message          |
            +----------------------------------------------------------+
            |  0 0 | Middle piece of a fragmented user message         |
            +----------------------------------------------------------+
            |  0 1 | Last piece of a fragmented user message           |
            +----------------------------------------------------------+
            |  1 1 | Unfragmented message                              |
            ============================================================
            |             Table 1: Fragment Description Flags          |
            ============================================================

ユーザーメッセージが複数のチャンクに断片化されると、TSNはメッセージを再構成するために受信者によって使用されます. これは、断片化されたユーザーメッセージの各フラグメントのTSNが厳密に連続している必要があることを意味します. 

長さ：16ビット（符号なし整数） 

このフィールドは、パディングを除く、タイプフィールドの先頭からユーザーデータフィールドの末尾までのデータチャンクの長さをバイト単位で示します. 1バイトのユーザーデータを持つDATAチャンクの長さは17（17バイトを示す）に設定されます. 

長さLのユーザーデータフィールドを持つDATAチャンクは、Lが0より大きくなければならない（16 + L）（16 + Lバイトを示す）に設定された長さフィールドを持ちます.  

TSN：32ビット（符号なし整数） 

この値は、このDATAチャンクのTSNを表します. TSNの有効範囲は0〜4294967295（2 ** 32-1）です. TSNは、4294967295に達した後、0に戻ります. 

ストリーム識別子S：16ビット（符号なし整数） 

次のユーザーデータが属するストリームを識別します.  

ストリームシーケンス番号n：16ビット（符号なし整数） 

この値は、ストリームS内の次のユーザーデータのストリームシーケンス番号を表します. 有効な範囲は0〜65535です.  

ユーザーメッセージがトランスポートのためにSCTPによってフラグメント化されるとき、同じストリームシーケンス番号がメッセージのフラグメントのそれぞれで運ばれなければなりません.  

ペイロードプロトコル識別子：32ビット（符号なし整数） 

この値は、アプリケーション（または上位層）が指定したプロトコル識別子を表します. この値は、上位層によってSCTPに渡され、ピアに送信されます. この識別子はSCTPでは使用されませんが、特定のネットワークエンティティおよびピアアプリケーションで使用され、このDATAチャンクで伝達される情報のタイプを識別できます. このフィールドは、フラグメント化されたDATAチャンクでも送信する必要があります（ネットワークの中央のエージェントが使用できるようにするため）. このフィールドは、SCTP実装の影響を受けないことに注意してください. したがって、そのバイト順は必ずしもビッグエンディアンではありません. 上位層は、このフィールドへのバイト順変換を担当します. 

値0は、このペイロードデータの上位層でアプリケーション識別子が指定されていないことを示します.  

ユーザーデータ：可変長 

これはペイロードのユーザーデータです. 実装は、データの終わりをすべてゼロのバイトで4バイト境界にパディングする必要があります. 長さフィールドにパディングを含めることはできません. 送信者は、3バイトを超えるパディングを決して追加してはなりません. 

3.3.2. 開始（INIT）（1）

このチャンクは、2つのエンドポイント間のSCTPアソシエーションを開始するために使用されます. INITチャンクの形式は次のとおりです. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 1    |  Chunk Flags  |      Chunk Length             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         Initiate Tag                          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           Advertised Receiver Window Credit (a_rwnd)          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |  Number of Outbound Streams   |  Number of Inbound Streams    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                          Initial TSN                          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       \                                                               \
       /              Optional/Variable-Length Parameters              /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

INITチャンクには次のパラメーターが含まれます. 特に明記しない限り、各パラメータはINITチャンクに1回だけ含める必要があります. 

固定パラメータステータス----------------------------------------------開始タグ必須アドバタイズされたレシーバーウィンドウクレジット必須アウトバウンドストリームの数必須インバウンドストリームの数必須初期TSN必須 

変数パラメータステータスタイプ値--------------------------------------------- ---------------- IPv4アドレス（注1）オプション5 IPv6アドレス（注1）オプション6 Cookie Preservativeオプション9 ECN対応（注2）オプション32768（0x8000）ホスト名前アドレス（注3）オプション11サポートされるアドレスタイプ（注4）オプション12 

注1：INITチャンクには、IPv4またはIPv6、あるいはその両方を任意に組み合わせた複数のアドレスを含めることができます.  

注2：ECN対応フィールドは、明示的輻輳通知の将来の使用のために予約されています.  

注3：INITチャンクには、複数のホスト名アドレスパラメータを含めることはできません. さらに、INITの送信者は、他のアドレスタイプをINITのホスト名アドレスと組み合わせてはいけません. 受信したINITチャンクにホスト名アドレスパラメータが存在する場合、INITの受信者は他のアドレスタイプを無視しなければなりません. 注4：このパラメーターは、存在する場合、送信エンドポイントがサポートできるすべてのアドレスタイプを指定します. このパラメーターがないことは、送信エンドポイントが任意のアドレスタイプをサポートできることを示します. 

実装に関する注：INITチャンクのオプションパラメータではない既知のパラメータを使用してINITチャンクを受信した場合、受信者はINITチャンクを処理し、INIT ACKを返送する必要があります（SHOULD）. INITチャンクの受信者は、後でCOOKIE A​​CKチャンクにERRORチャンクをバンドルしてもよい（MAY）. ただし、制限的な実装では、INITチャンクに応答してABORTチャンクを送り返す場合があります. 

INITのチャンクフラグフィールドは予約されており、その中のすべてのビットは送信者によって0に設定され、受信者によって無視される必要があります. INIT内の一連のパラメーターは、任意の順序で処理できます. 

タグを開始：32ビット（符号なし整数） 

INITの受信側（応答側）は、タグの開始パラメーターの値を記録します. この値は、INITの受信者がこのアソシエーション内で送信するすべてのSCTPパケットの検証タグフィールドに配置する必要があります. 

開始タグには、0以外の任意の値を指定できます. タグ値の選択の詳細については、セクション5.3.1を参照してください.  

受信したINITチャンクの開始タグの値が0であることが判明した場合、受信者はそれをエラーとして扱い、ABORTを送信することにより関連付けを閉じなければなりません.  

アドバタイズされたレシーバーウィンドウクレジット（a_rwnd）：32ビット（符号なし整数） 

この値は、INITの送信者がこのウィンドウに関連して予約した専用バッファスペースをバイト数で表します. アソシエーションの存続期間中、このバッファスペースを減らすことはできません（つまり、このアソシエーションから削除された専用バッファ）. ただし、エンドポイントは、SACKチャンクで送信するa_rwndの値を変更できます（MAY）. 

アウトバウンドストリーム（OS）の数：16ビット（符号なし整数） 

このINITチャンクの送信者がこの関連付けで作成するアウトバウンドストリームの数を定義します. 値0は使用しないでください. 

注：OS値が0に設定されたINITの受信者は、関連付けを中止する必要があります.  

インバウンドストリーム数（MIS）：16ビット（符号なし整数） 

このINITチャンクの送信者がこの関連付けでピアエンドが作成できるストリームの最大数を定義します. 値0は使用しないでください. 

注：実際のストリーム数のネゴシエーションはありませんが、代わりに2つのエンドポイントはmin（requested、offer）を使用します. 詳細については、セクション5.1.1を参照してください. 

注：MIS値が0のINITの受信者は、関連付けを中止する必要があります.  

初期TSN（I-TSN）：32ビット（符号なし整数） 

送信者が使用する初期TSNを定義します. 有効な範囲は0〜4294967295です. このフィールドは、[タグの開始]フィールドの値に設定できます. 

3.3.2.1. INITのオプション/可変長パラメーター

次のパラメータは、セクション3.2.1で定義されているType-Length-Value形式に従います. Type-Length-Valueフィールドは、前のセクションで定義された固定長フィールドの後に来なければなりません. 

IPv4アドレスパラメーター（5） 

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 5 | 長さ= 8 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | IPv4アドレス| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+

IPv4アドレス：32ビット（符号なし整数） 

送信エンドポイントのIPv4アドレスが含まれます. バイナリエンコードされています. 

















IPv6アドレスパラメーター（6） 

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 6 | 長さ= 20 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | | | IPv6アドレス| | | | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+

IPv6アドレス：128ビット（符号なし整数） 

送信エンドポイントのIPv6 [RFC2460]アドレスが含まれます. バイナリエンコードされています. 

注：送信者は、IPv4にマップされたIPv6アドレス[RFC4291]を使用してはなりませんが、代わりにIPv4アドレスにIPv4アドレスパラメータを使用する必要があります.  

SCTP共通ヘッダーの送信元ポート番号と組み合わせて、IPv4またはIPv6アドレスパラメーターで渡される値は、INITの送信者が開始されるアソシエーションに対してサポートするトランスポートアドレスを示します. つまり、この関連付けの存続期間中、このIPアドレスは、INITの送信者から送信されたIPデータグラムの送信元アドレスフィールドに表示され、受信者から送信されたIPデータグラムの宛先アドレスとして使用できます.  INIT. 

INIT送信者がマルチホームの場合、複数のIPアドレスパラメータをINITチャンクに含めることができます. さらに、マルチホームエンドポイントは、さまざまなタイプのネットワークにアクセスできます. したがって、1つのINITチャンクに複数のアドレスタイプが存在する可能性があります. つまり、同じINITチャンクでIPv4アドレスとIPv6アドレスが許可されます. 

INITに少なくとも1つのIPアドレスパラメータが含まれている場合、INITチャンクを含むIPデータグラムのソースアドレスと、INIT内で提供される追加アドレスは、INITを受信するエンドポイントによって宛先として使用できます. INITにIPアドレスパラメータが含まれていない場合、INITを受信するエンドポイントは、受信したIPデータグラムに関連付けられた送信元アドレスを、関連付けの唯一の宛先アドレスとして使用する必要があります. 

INITおよびINIT ACKでIPアドレスパラメータを使用しないことは、NATボックス全体で動作する可能性を高めるための代替手段であることに注意してください. クッキー保存料（9）

INITの送信者は、このパラメータを使用して、INITの受信者に状態Cookieのより長い寿命を示唆するものとします.  

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 9 | 長さ= 8 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 推奨されるCookieの有効期間の増分（ミリ秒）| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+

推奨されるCookieの有効期間の増分：32ビット（符号なし整数） 

このパラメーターは、送信者がデフォルトのCookieの有効期間に追加することを受信者に希望する増分をミリ秒単位で受信者に示します.  

このオプションのパラメータは、送信者がINITチャンクに追加する必要があります. 送信者は、古いCookie操作エラーのために以前のアソシエーションの確立に失敗したピアとのアソシエーションの確立を再試行します. 受信者は、独自のセキュリティ上の理由から、推奨されるCookieの寿命の延長を無視することを選択する場合があります. 

ホスト名アドレス（11） 

INITの送信者は、このパラメーターを使用して、（IPアドレスの代わりに）ホスト名をピアに渡します. ピアは、名前を解決する責任があります. このパラメーターを使用すると、NATボックス全体で関連付けが機能する可能性が高くなります. 

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 11 | 長さ| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ /ホスト名/ \ \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

ホスト名：可変長 

このフィールドには、RFC 1123セクション2.1 [RFC1123]の「ホスト名構文」にホスト名が含まれています. ホスト名を解決する方法は、SCTPの範囲外です. 

注：少なくとも1つのヌルターミネーターがホスト名文字列に含まれており、長さに含める必要があります.  

サポートされているアドレスの種類（12） 

INITの送信者は、このパラメーターを使用して、サポート可能なすべてのアドレスタイプを一覧表示します.  

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 12 | 長さ| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | アドレスタイプ＃1 | アドレスタイプ＃2 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | ...... | +-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+ -+-+-+-++-+-+-+

アドレスタイプ：16ビット（符号なし整数） 

これには、対応するアドレスTLVのタイプ値が入力されます（たとえば、IPv4 = 5、IPv6 = 6、ホスト名= 11）.  

3.3.3. 開始確認（INIT ACK）（2）

INIT ACKチャンクは、SCTPアソシエーションの開始を確認するために使用されます.  

INIT ACKのパラメーター部分は、INITチャンクと同様にフォーマットされます. 状態Cookieと認識されないパラメーターの2つの追加変数パラメーターを使用します. 

































INIT ACKチャンクの形式は次のとおりです.  

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 2 | チャンクフラグ| チャンク長| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | タグを開始| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | アドバタイズドレシーバーウィンドウクレジット| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | アウトバウンドストリームの数| インバウンドストリームの数| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 初期TSN | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ \

タグを開始：32ビット（符号なし整数） 

INIT ACKの受信者は、Initiate Tagパラメータの値を記録します. この値は、INIT ACK受信者がこのアソシエーション内で送信するすべてのSCTPパケットの検証タグフィールドに配置する必要があります. 

開始タグは値0をとってはなりません. 開始タグ値の選択の詳細については、セクション5.3.1を参照してください.  

受信したINIT ACKチャンクのInitiate Tagの値が0であることが判明した場合、受信者はそのTCBを破棄するアソシエーションを破棄しなければなりません. 受信者は、デバッグ目的でABORTを送信できます. 

アドバタイズされたレシーバーウィンドウクレジット（a_rwnd）：32ビット（符号なし整数） 

この値は、INIT ACKの送信者がこのウィンドウに関連して予約した専用のバッファスペースをバイト数で表します. アソシエーションの存続期間中、このバッファスペースを減らすことはできません（つまり、このアソシエーションから削除された専用バッファ）. 

アウトバウンドストリーム（OS）の数：16ビット（符号なし整数） 

このINIT ACKチャンクの送信者がこの関連付けで作成するアウトバウンドストリームの数を定義します. 値0は使用してはならず、値はINITチャンクで送信されたMIS値より大きくしてはなりません. 

注：OS値が0に設定されたINIT ACKの受信者は、TCBを破棄する関連付けを破棄する必要があります.  

インバウンドストリーム数（MIS）：16ビット（符号なし整数） 

このINIT ACKチャンクの送信者がこの関連付けでピアエンドが作成できるストリームの最大数を定義します. 値0は使用しないでください. 

注：実際のストリーム数のネゴシエーションはありませんが、代わりに2つのエンドポイントはmin（requested、offer）を使用します. 詳細については、セクション5.1.1を参照してください. 

注：MIS値が0に設定されたINIT ACKの受信者は、TCBを破棄して関連付けを破棄する必要があります.  

初期TSN（I-TSN）：32ビット（符号なし整数） 

INIT ACK送信者が使用する初期TSNを定義します. 有効な範囲は0〜4294967295です. このフィールドは、[タグの開始]フィールドの値に設定できます. 

固定パラメータステータス----------------------------------------------開始タグ必須アドバタイズされたレシーバーウィンドウクレジット必須アウトバウンドストリームの数必須インバウンドストリームの数必須初期TSN必須 

変数パラメータステータスタイプ値--------------------------------------------- ----------------状態Cookie必須7 IPv4アドレス（注1）オプション5 IPv6アドレス（注1）オプション6認識されないパラメーターオプション8 ECN対応（注2）オプション32768 （0x8000）ホスト名アドレス（注3）オプション11 

注1：INIT ACKチャンクには、IPv4またはIPv6、あるいはその両方を組み合わせた任意の数のIPアドレスパラメーターを含めることができます.  

注2：ECN対応フィールドは、明示的輻輳通知の将来の使用のために予約されています.  

注3：INIT ACKチャンクに複数のホスト名アドレスパラメータを含めることはできません. さらに、INIT ACKの送信者は、他のアドレスタイプをINIT ACKのホスト名アドレスと組み合わせてはなりません. ホスト名アドレスパラメータが存在する場合、INIT ACKの受信者は他のアドレスタイプを無視しなければなりません. 

実装ノート：実装は、ステートCookieの可変サイズと可変アドレスリストのために、非常に大きい（1500バイトを超える）INIT ACKを受信する準備をする必要があります. たとえば、INITに対するレスポンダーが送信するIPv4アドレスを1000個持っている場合、これをINIT ACKでエンコードするには少なくとも8,000バイトが必要です. 

実装注：INIT ACKチャンクのオプションのパラメーターではない既知のパラメーターでINIT ACKチャンクを受信した場合、受信者はINIT ACKチャンクを処理し、COOKIE ECHOを返送する必要があります. INIT ACKチャンクの受信者は、ERRORチャンクをCOOKIE ECHOチャンクにバンドルしてもよい（MAY）. ただし、制限的な実装では、INIT ACKチャンクに応答してABORTチャンクを返送する場合があります. 

SCTP共通ヘッダーで送信される送信元ポートとの組み合わせで、INIT ACKの各IPアドレスパラメーターは、INIT ACKの受信者に、開始されているアソシエーションのライフタイムの間、INIT ACKの送信者がサポートする有効なトランスポートアドレスを示します.  

INIT ACKに少なくとも1つのIPアドレスパラメータが含まれる場合、INIT ACKを含むIPデータグラムのソースアドレスと、INIT ACK内で提供される追加アドレスは、INIT ACKの受信者によって宛先として使用できます. INIT ACKにIPアドレスパラメータが含まれていない場合、INIT ACKの受信者は、受信したIPデータグラムに関連付けられた送信元アドレスを、関連付けの唯一の宛先アドレスとして使用する必要があります. 

状態Cookieおよび認識されないパラメーターは、セクション3.2.1で定義されているType-Length-Value形式を使用し、以下で説明します. 他のフィールドは、INITチャンクの対応するフィールドと同じように定義されます. 

3.3.3.1. オプションまたは可変長パラメーター

状態クッキー 

パラメータタイプ値：7 

パラメーターの長さ：Cookieのサイズに応じて可変サイズ.  

パラメータ値： 

このパラメータ値には、このINIT ACKの送信者がメッセージ認証コード（MAC）とともにアソシエーションを作成するために必要なすべての必要な状態とパラメータ情報を含める必要があります. ステートクッキーの定義の詳細については、セクション5.1.3を参照してください. 

認識されないパラメーター： 

パラメータタイプ値：8 

パラメーターの長さ：可変サイズ.  

パラメータ値： 

このパラメーターは、送信者に報告する必要があることを示す値を持つ認識されないパラメーターがINITに含まれている場合、INITチャンクの発信元に返されます. このパラメーター値フィールドには、パラメータータイプ、長さ、および値フィールドを備えたINITチャンクからコピーされた認識されないパラメーターが含まれます. 

3.3.4. 選択的確認応答（SACK）（3）

このチャンクはピアのエンドポイントに送信され、受信したDATAチャンクを確認し、TSNで表されるDATAチャンクの受信したサブシーケンスのギャップをピアのエンドポイントに通知します.  

SACKには、累積TSN Ack、アドバタイズされた受信者ウィンドウクレジット（a_rwnd）、ギャップAckブロックの数、および重複TSNの数フィールドを含める必要があります.  

定義により、累積TSN Ackパラメーターの値は、受信したTSNのシーケンスにブレークが発生する前に受信した最後のTSNです. この値に続く次のTSN値は、SACKを送信するエンドポイントでまだ受信されていません. したがって、このパラメーターは、その値以下のすべてのTSNの受信を確認します. 

SACKの受信者によるa_rwndの処理については、セクション6.2.1で詳しく説明します.  

SACKには、0個以上のGap Ackブロックも含まれます. 各Gap Ackブロックは、受信したTSNのシーケンスの中断後に受信したTSNのサブシーケンスを確認します. 定義により、ギャップAckブロックによって確認されたすべてのTSNは、累積TSN Ackの値よりも大きくなります. 



0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 3 |チャンクフラグ| チャンク長| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 累積TSN確認| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | アドバタイズされたレシーバーウィンドウクレジット（a_rwnd）| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | ギャップAckブロック数= N | 重複TSNの数= X | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | Gap Ack Block＃1 Start | ギャップAckブロック＃1終了| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ / / \ ... \ / / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+ | ギャップAckブロック#N開始| ギャップAckブロック#N終了| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | TSN 1の複製| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ / / \ ... \ / / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -+-+-+-+-+-+-+-+-+ | TSN Xの複製| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+

チャンクフラグ：8ビット 

送信時にすべて「0」に設定され、受信時には無視されます.  

累積TSN Ack：32ビット（符号なし整数） 

このパラメーターには、ギャップの前に順番に受信された最後のDATAチャンクのTSNが含まれます. DATAチャンクが受信されていない場合、この値はピアの初期TSNから1を引いた値に設定されます. 

アドバタイズされたレシーバーウィンドウクレジット（a_rwnd）：32ビット（符号なし整数） 

このフィールドは、このSACKの送信者の更新された受信バッファスペースをバイト単位で示します. 詳細については、セクション6.2.1を参照してください. 

ギャップAckブロックの数：16ビット（符号なし整数） 

このSACKに含まれるギャップAckブロックの数を示します.  

重複TSNの数：16ビット 

このフィールドには、エンドポイントが受信した重複TSNの数が含まれます. 重複する各TSNは、Gap Ack Blockリストの後にリストされます. 

ギャップAckブロック： 

これらのフィールドには、ギャップAckブロックが含まれます. これらは、ギャップAckブロックの数フィールドで定義されたギャップAckブロックの数まで、各ギャップAckブロックに対して繰り返されます. 各Gap AckブロックのTSNが（累積TSN Ack +ギャップAckブロック開始）以上で（累積TSN Ack +ギャップAckブロック終了）以下のすべてのDATAチャンクは、正しく受信されたと見なされます. 

Gap Ack Block Start：16ビット（符号なし整数） 

このギャップAckブロックの開始オフセットTSNを示します. 実際のTSN番号を計算するために、累積TSN ACKがこのオフセット番号に追加されます. この計算されたTSNは、受信されたこのギャップAckブロックの最初のTSNを識別します. 

Gap Ack Block End：16ビット（符号なし整数） 

このギャップAckブロックの終了オフセットTSNを示します. 実際のTSN番号を計算するために、累積TSN Ackがこのオフセット番号に追加されます. この計算されたTSNは、このGap Ackブロックで受信された最後のDATAチャンクのTSNを識別します. 





































たとえば、受信者が選択的ACKを送信することを決定したときに、次のDATAチャンクが新しく到着したと仮定します.  

---------- | TSN = 17 | ---------- | | <-まだ欠落している---------- | TSN = 15 | ---------- | TSN = 14 | ---------- | | <-まだ欠落している---------- | TSN = 12 | ---------- | TSN = 11 | ---------- | TSN = 10 | ----------

次に、SACKのパラメータ部分を次のように構築する必要があります（新しいa_rwndが送信者によって4660に設定されていると仮定）： 

+ -------------------------------- + | 累積TSN確認= 12 | + -------------------------------- + | a_rwnd = 4660 | + ---------------- + --------------- + | ブロックの数= 2 | num of dup = 0 | + ---------------- + --------------- + | block＃1 strt = 2 | block＃1 end = 3 | + ---------------- + --------------- + | block＃2 strt = 5 | block＃2 end = 5 | + ---------------- + --------------- +

TSNの重複：32ビット（符号なし整数） 

最後のSACKが送信されてからTSNが重複して受信された回数を示します. 受信者は、重複したTSNを取得するたびに（SACKを送信する前に）、重複のリストに追加します. 重複カウントは、各SACKの送信後にゼロに再初期化されます. 

たとえば、受信者がTSN 19を3回取得すると、送信SACKに19回2回リストされます. SACKを送信した後、さらに1つのTSN 19を受信した場合、次の発信SACKで重複として19をリストします. 3.3.5. ハートビート要求（ハートビート）（4）

エンドポイントは、このチャンクをピアエンドポイントに送信して、現在のアソシエーションで定義されている特定の宛先トランスポートアドレスの到達可能性をプローブする必要があります. 

パラメータフィールドには、送信者のみが理解できる可変長の不透明なデータ構造であるハートビート情報が含まれます.  

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 4 | チャンクフラグ| ハートビートの長さ| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ \ \ /ハートビート情報TLV（可変長）/ \ \ +-+-+-+-+-+-+-+-+-+-+ -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

チャンクフラグ：8ビット 

送信時に0に設定され、受信時には無視されます.  

ハートビート長：16ビット（符号なし整数） 

チャンクヘッダーとハートビート情報フィールドを含む、バイト単位のチャンクのサイズに設定します.  

ハートビート情報：可変長 

セクション3.2.1で説明されている形式を使用して、可変長パラメーターとして定義されます.  

変数パラメータステータスタイプ値--------------------------------------------- ----------------ハートビート情報必須1 

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | ハートビート情報タイプ= 1 | HB情報の長さ| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ /送信者固有のハートビート情報/ \ \ +-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

送信者固有のハートビート情報フィールドには、通常、このHEARTBEATチャンクが送信される送信者の現在時刻と、このHEARTBEATが送信される宛先トランスポートアドレスに関する情報が含まれます（セクション8.3を参照）. この情報は、受信者によってハートビートACKメッセージに単純に反映されます（セクション3.3.6を参照）. また、HEARTBEATメッセージは到達可能性チェックとパス検証の両方に使用されることに注意してください（セクション5.4を参照）. HEARTBEATチャンクがパス検証の目的で使用されている場合、64ビットのランダムナンスを保持する必要があります. 

3.3.6. ハートビート謝辞（ハートビートACK）（5）

エンドポイントは、このチャンクをHEARTBEATチャンクへの応答としてピアエンドポイントに送信する必要があります（セクション8.3を参照）. HEARTBEAT ACKは、このACKが応答するHEARTBEATチャンクを含むIPデータグラムのソースIPアドレスに常に送信されます. 

パラメータフィールドには、可変長の不透明なデータ構造が含まれています.  

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 5 | チャンクフラグ| ハートビートAckの長さ| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ \ \ /ハートビート情報TLV（可変長）/ \ \ +-+-+-+-+-+-+-+-+-+-+ -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

チャンクフラグ：8ビット 

送信時に0に設定され、受信時には無視されます.  

ハートビートAck長：16ビット（符号なし整数） 

チャンクヘッダーとハートビート情報フィールドを含む、バイト単位のチャンクのサイズに設定します.  

ハートビート情報：可変長 

このフィールドには、このハートビート肯定応答が応答しているハートビート要求のハートビート情報パラメーターが含まれている必要があります.  

変数パラメータステータスタイプ値--------------------------------------------- ----------------ハートビート情報必須1 





3.3.7. アソシエーションの中止（ABORT）（6）

ABORTチャンクが関連付けのピアに送信され、関連付けが閉じられます. ABORTチャンクには、中止の理由を受信者に通知する原因パラメータが含まれる場合があります. データチャンクをABORTにバンドルしないでください. 制御チャンク（INIT、INIT ACK、およびSHUTDOWN COMPLETEを除く）はABORTにバンドルできますが、SCTPパケットのABORTの前に配置する必要があります. そうしないと、受信者によって無視されます. 

エンドポイントがフォーマットエラーでABORTを受信した場合、またはTCBが見つからない場合、エンドポイントは静かにそれを破棄しなければなりません. さらに、どのような状況でも、ABORTを受信するエンドポイントは、独自のABORTを送信してそのABORTに応答してはなりません. 

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 6 |予約済み| T | 長さ| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ \ \ / zero or more Error Causes / \ \ +-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

チャンクフラグ：8ビット 

予約済み：7ビット 

送信時に0に設定され、受信時には無視されます.  

Tビット：1ビット 

送信者がピアが期待する検証タグに入力した場合、Tビットは0に設定されます. 検証タグが反映される場合、Tビットを1に設定する必要があります. 反映は、送信された検証タグが受信した検証タグと同じであることを意味します. 

注：検証のために、このチャンクに特別な規則が適用されます. 詳細については、セクション8.5.1を参照してください. 

長さ：16ビット（符号なし整数） 

チャンクヘッダーと存在するすべてのエラー原因フィールドを含む、バイト単位のチャンクのサイズに設定します.  

エラー原因の定義については、セクション3.3.10を参照してください.  

3.3.8. シャットダウン協会（SHUTDOWN）（7）

アソシエーションのエンドポイントは、このチャンクを使用して、ピアとのアソシエーションのグレースフルクローズを開始する必要があります. このチャンクの形式は次のとおりです. 

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 7 | チャンクフラグ| 長さ= 8 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 累積TSN確認| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+

チャンクフラグ：8ビット 

送信時に0に設定され、受信時には無視されます.  

長さ：16ビット（符号なし整数） 

パラメーターの長さを示します. 8に設定します. 

累積TSN Ack：32ビット（符号なし整数） 

このパラメーターには、ギャップの前に順番に受信された最後のチャンクのTSNが含まれます.  

注：SHUTDOWNメッセージにはGap Ackブロックが含まれていないため、順不同で受信したTSNを確認するために使用することはできません. SACKでは、以前に含まれていたGap Ack Blockの欠如は、データレシーバーが関連するDATAチャンクで無効になったことを示します. SHUTDOWNにはGap Ack Blockが含まれていないため、SHUTDOWNの受信側はGap Ack Blockの欠如を更新と解釈すべきではありません. （更新の詳細については、セクション6.2を参照してください. ）

3.3.9. シャットダウン確認（SHUTDOWN ACK）（8）

このチャンクは、シャットダウンプロセスの完了時にSHUTDOWNチャンクの受信を確認するために使用する必要があります. 詳細については、セクション9.2を参照してください. 

SHUTDOWN ACKチャンクにはパラメーターがありません.  











0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 8 |チャンクフラグ| 長さ= 4 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+

チャンクフラグ：8ビット 

送信時に0に設定され、受信時には無視されます.  

3.3.10. 操作エラー（ERROR）（9）

エンドポイントはこのチャンクをピアエンドポイントに送信して、特定のエラー状態を通知します. 1つ以上のエラー原因が含まれています. 操作エラー自体は致命的とは見なされませんが、致命的な状態を報告するためにABORTチャンクと共に使用できます. 以下のパラメーターがあります. 

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 9 | チャンクフラグ| 長さ| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ \ \ / 1つ以上のエラー原因/ \ \ +-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

チャンクフラグ：8ビット 

送信時に0に設定され、受信時には無視されます.  

長さ：16ビット（符号なし整数） 

チャンクヘッダーと存在するすべてのエラー原因フィールドを含む、バイト単位のチャンクのサイズに設定します.  























エラー原因は、セクション3.2.1で説明されている形式を使用した可変長パラメーターとして定義されます.  

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | 原因コード| 原因の長さ| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ /原因固有の情報/ \ \ +-+-+-+-+-+-+-+-+-+-+-+-+-+ -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

原因コード：16ビット（符号なし整数） 

報告されるエラー状態のタイプを定義します.  

原因コードの値原因コード--------- ---------------- 1無効なストリーム識別子2必須パラメーターの欠落3古いCookieエラー4リソース不足5解決不能なアドレス6認識されないチャンクタイプ7無効な必須パラメーター8認識されないパラメーター9ユーザーデータなし10シャットダウン中に受信したCookie 11新しいアドレスとのアソシエーションの再開12ユーザーが開始した中止13プロトコル違反 

原因の長さ：16ビット（符号なし整数） 

原因コード、原因の長さ、原因固有の情報フィールドなど、バイト単位のパラメーターのサイズに設定します.  

原因固有の情報：可変長 

このフィールドには、エラー状態の詳細が含まれます.  

セクション3.3.10.1-セクション3.3.10.13は、SCTPのエラー原因を定義します. IETFが新しいエラー原因値を定義するためのガイドラインについては、セクション14.3で説明します. 





3.3.10.1. 無効なストリーム識別子（1）

エラーの原因--------------- 

無効なストリーム識別子：エンドポイントが、存在しないストリームに送信されたDATAチャンクを受信したことを示します.  

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 原因コード= 1 | 原因の長さ= 8 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | ストリーム識別子| （予約済み）| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+

ストリーム識別子：16ビット（符号なし整数） 

エラーで受信したDATAチャンクのストリーム識別子が含まれます.  

予約済み：16ビット 

このフィールドは予約されています. 送信時にはすべて0に設定され、受信時には無視されます. 

3.3.10.2. 必須パラメーターがありません（2）

エラーの原因--------------- 

必須パラメーターの欠落：受信したINITまたはINIT ACKで1つ以上の必須TLVパラメーターが欠落していることを示します.  

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 原因コード= 2 | 原因の長さ= 8 + N * 2 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 欠落パラメータの数= N | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | Param Type＃1がありません| Param Type＃2がありません| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | パラメータタイプ＃N-1がありません| パラメータタイプ#Nがありません| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+

欠落しているパラメーターの数：32ビット（符号なし整数） 

このフィールドには、原因固有情報フィールドに含まれるパラメーターの数が含まれます.  



パラメータタイプの欠落：16ビット（符号なし整数） 

各フィールドには、欠落している必須パラメーター番号が含まれます.  

3.3.10.3. 古いCookieエラー（3）

エラーの原因-------------- 

古いCookieエラー：有効期限が切れた有効な状態Cookieの受信を示します.  

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 原因コード= 3 | 原因の長さ= 8 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 古さの測定（usec. ）| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+

古さの尺度：32ビット（符号なし整数） 

このフィールドには、現在の時刻と状態Cookieの期限が切れた時刻との差がマイクロ秒単位で含まれています.  

このエラーの送信者は、「古さの測定」フィールドにゼロ以外の値を含めることにより、状態Cookieの有効期限が切れるまでの時間を報告することを選択できます. 送信者がこの情報を提供することを望まない場合、古さの測定フィールドをゼロの値に設定する必要があります. 

3.3.10.4. リソース不足（4）

エラーの原因--------------- 

リソース不足：送信者のリソース不足を示します. これは通常、ABORTと組み合わせて、またはABORT内で送信されます. 

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 原因コード= 4 | 原因の長さ= 4 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+















3.3.10.5. 解決できないアドレス（5）

エラーの原因--------------- 

解決できないアドレス：送信者が指定されたアドレスパラメータを解決できないことを示します（たとえば、アドレスの種類は送信者によってサポートされていません）. これは通常、ABORTと組み合わせて、またはABORT内で送信されます. 

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 原因コード= 5 | 原因の長さ| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ /解決できないアドレス/ \ \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

解決できないアドレス：可変長 

[解決できないアドレス]フィールドには、解決できないアドレスまたはホスト名を含むアドレスパラメーター（またはホスト名パラメーター）の完全なタイプ、長さ、および値が含まれます.  

3.3.10.6. 認識されないチャンクタイプ（6）

エラーの原因--------------- 

認識されないチャンクタイプ：このエラー原因は、受信側がチャンクを理解せず、「チャンクタイプ」の上位ビットが01または11に設定されている場合、チャンクの発信元に返されます.  

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 原因コード= 6 | 原因の長さ| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ /認識されないチャンク/ \ \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

認識されないチャンク：可変長 

認識されないチャンクフィールドには、チャンクタイプ、チャンクフラグ、およびチャンク長を備えたSCTPパケットからの認識されないチャンクが含まれます.  







3.3.10.7. 無効な必須パラメーター（7）

エラーの原因--------------- 

無効な必須パラメーター：必須パラメーターの1つが無効な値に設定されている場合、このエラー原因はINITまたはINIT ACKチャンクの発信元に返されます.  

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 原因コード= 7 | 原因の長さ= 4 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+

3.3.10.8. 認識されないパラメーター（8）

エラーの原因--------------- 

認識されないパラメーター：このエラー原因は、受信側がINIT ACKチャンク内の1つ以上のオプションのTLVパラメーターを認識しない場合に、INIT ACKチャンクの発信者に返されます.  

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 原因コード= 8 | 原因の長さ| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ /認識されないパラメーター/ \ \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

認識されないパラメーター：可変長 

Unrecognized Parametersフィールドには、TLVで完了したINIT ACKチャンクからコピーされた認識されないパラメーターが含まれます. このエラーの原因は、通常、COOKIE ECHOチャンクの送信者が認識されないパラメータを報告したい場合に、INIT ACKに応答するときにCOOKIE ECHOチャンクにバンドルされたERRORチャンクに含まれます. 





















3.3.10.9. ユーザーデータなし（9）

エラーの原因--------------- 

ユーザーデータなし：このエラーの原因は、 

受信したDATAチャンクにユーザーデータがない場合は、DATAチャンク.  

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 原因コード= 9 | 原因の長さ= 8 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ / TSN値/ \ \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

TSN値：32ビット（符号なし整数） 

TSN値フィールドには、ユーザーデータフィールドなしで受信したDATAチャンクのTSNが含まれます.  

この原因コードは通常、ABORTチャンクで返されます（セクション6.2を参照）.  

3.3.10.10. シャットダウン中に受信したCookie（10）

エラーの原因--------------- 

シャットダウン中に受信したCookie：エンドポイントがSHUTDOWN-ACK-SENT状態にあるときにCOOKIE ECHOを受信しました. このエラーは通常、再送されたSHUTDOWN ACKにバンドルされたERRORチャンクで返されます. 

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 原因コード= 10 | 原因の長さ= 4 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+





















3.3.10.11. 新しいアドレスとの関連付けの再開（11）

エラーの原因-------------- 

新しいアドレスとの関連付けの再開：既存の関連付けでINITが受信されました. しかし、INITは、以前はアソシエーションの一部ではなかったアドレスをアソシエーションに追加しました. 新しいアドレスはエラーコードにリストされています. このエラーは通常、INITを拒否するABORTの一部として送信されます（セクション5.2を参照）. 

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | 原因コード= 11 | 原因の長さ=変数| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ /新しいアドレスTLV / \ \ +-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

注：各新しいアドレスTLVは、パラメータタイプやパラメータ長など、新しいINITチャンクで見つかったTLVの正確なコピーです.  

3.3.10.12. ユーザー開始の中止（12）

エラーの原因-------------- 

このエラーの原因は、上位層のリクエストのために送信されるABORTチャンクに含まれる場合があります. 上位層は、SCTPによって透過的にトランスポートされ、ピアで上位層プロトコルに配信される場合がある上位層中止理由を指定できます. 

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | 原因コード= 12 | 原因の長さ=変数| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ /上層中止理由/ \ \ +-+-+-+-+-+-+-+-+-+-+-+-+-+ -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+











3.3.10.13. プロトコル違反（13）

エラーの原因-------------- 

SCTPエンドポイントが、セクション3.3.10.1からセクション3.3.10.12で説明されているエラー原因でカバーされていないピアのプロトコル違反を検出するため、このエラー原因は送信されるABORTチャンクに含まれる場合があります. 実装は、検出されたプロトコル違反の種類を指定する追加情報を提供する場合があります. 

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | 原因コード= 13 | 原因の長さ=変数| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ /追加情報/ \ \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

3.3.11. クッキーエコー（COOKIE ECHO）（10）

このチャンクは、関連付けの初期化中にのみ使用されます. アソシエーションのイニシエータからピアに送信され、初期化プロセスを完了します. このチャンクは、アソシエーション内で送信されるDATAチャンクの前になければなりませんが、同じパケット内の1つ以上のDATAチャンクにバンドルされる場合があります. 

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 10 |チャンクフラグ| 長さ| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ / Cookie / \ \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

チャンクフラグ：8ビット 

送信時に0に設定され、受信時には無視されます.  

長さ：16ビット（符号なし整数） 

チャンクヘッダーの4バイトとCookieのサイズを含む、バイト単位のチャンクのサイズに設定します.  



Cookie：可変サイズ 

このフィールドには、以前のINIT ACKからState Cookieパラメーターで受信した正確なCookieが含まれている必要があります.  

実装は、相互運用性を確保するためにCookieをできるだけ小さくする必要があります.  

注：Cookie EchoにはState Cookieパラメーターは含まれません. 代わりに、状態Cookieのパラメーター値内のデータは、Cookie Echoのチャンク値内のデータになります. これにより、実装は、State Cookieパラメーターの最初の2バイトのみを変更して、COOKIE ECHOチャンクにすることができます. 

3.3.12. Cookie Acknowledgement（COOKIE A​​CK）（11）

このチャンクは、関連付けの初期化中にのみ使用されます. COOKIE ECHOチャンクの受信を確認するために使用されます. このチャンクは、アソシエーション内で送信されるDATAチャンクまたはSACKチャンクの前になければなりませんが、同じSCTPパケット内の1つ以上のDATAチャンクまたはSACKチャンクとバンドルされる場合があります. 

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 11 |チャンクフラグ| 長さ= 4 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+

チャンクフラグ：8ビット 

送信時に0に設定され、受信時には無視されます.  

3.3.13. シャットダウン完了（シャットダウン完了）（14）

このチャンクは、シャットダウンプロセスの完了時にSHUTDOWN ACKチャンクの受信を確認するために使用する必要があります. 詳細については、セクション9.2を参照してください. 

SHUTDOWN COMPLETEチャンクにはパラメーターがありません.  

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | タイプ= 14 |予約済み| T | 長さ= 4 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+

チャンクフラグ：8ビット 

予約済み：7ビット 

送信時に0に設定され、受信時には無視されます.  

Tビット：1ビット 

送信者がピアが期待する検証タグに入力した場合、Tビットは0に設定されます. 検証タグが反映される場合、Tビットを1に設定する必要があります. 反映は、送信された検証タグが受信した検証タグと同じであることを意味します. 

注：このチャンクには検証のための特別なルールが適用されます. 詳細についてはセクション8.5.1を参照してください.  

4. SCTPアソシエーションの状態図 

SCTPアソシエーションの存続期間中、SCTPエンドポイントのアソシエーションは、さまざまなイベントに応じて1つの状態から別の状態に進みます. アソシエーションの状態を潜在的に進める可能性のあるイベントには次のものがあります. 

o SCTPユーザープリミティブコール、たとえば、[ASSOCIATE]、[SHUTDOWN]、[ABORT]、 

o INIT、COOKIE ECHO、ABORT、SHUTDOWNなどの受信、チャンクの制御、または 

oいくつかのタイムアウトイベント.  

以下の図の状態図は、状態の変化を、原因となるイベントと結果のアクションとともに示しています. エラー状態の一部は状態図に表示されていないことに注意してください. すべての特殊なケースの詳細な説明は本文に記載されています. 

注：チャンク名はすべて大文字で示されますが、パラメーター名の最初の文字は大文字になります（例：COOKIE ECHOチャンクタイプと状態Cookieパラメーター）. 状態遷移を引き起こす複数のイベント/メッセージが発生する可能性がある場合、（A）、（B）などのラベルが付けられます. 





















----- --------（任意の状態から）/ \ / rcv ABORT [ABORT] rcv INIT | | | ----------または---------- --------------- | vv TCBの削除snd ABORT Cookieの生成\ + --------- + TCBの削除snd INIT ACK --- | 閉店| + --------- + / \ [アソシエイト] / \ --------------- | | TCBを作成する| | snd INIT | | strt init timer rcv valid | | クッキーエコー| v（1）---------------- | + ------------ + TCBの作成| | クッキー待ち| （2）snd COOKIE A​​CK | + ------------ + | | | | rcv INIT ACK | | ----------------- | | snd COOKIE ECHO | | 初期化タイマーを停止する| | strt cookieタイマー| v | + -------------- + | | クッキーエコー| （3）| + -------------- + | | | | rcv COOKIE A​​CK | | ----------------- | | Cookieタイマーvvの停止+ --------------- + | 設立済み| + --------------- +

























（ESTABLISHED状態からのみ）| | / -------- + -------- \ [シャットダウン] / \ ------------------- | | 未処理のチェック| | データチャンク| | v | + --------- + | |シャットダウン-| | rcvシャットダウン|保留中| | ------------------ + --------- + | 未処理のチェック| | データチャンク | --------------------- | | sndシャットダウン| | strtシャットダウンタイマー| | vv + --------- + + ----------- +（4）| SHUTDOWN- | | シャットダウン-| （5、6）| SENT | | 受信済み| + --------- + + ----------- + | \ | （A）rcvシャットダウンACK | \ | ---------------------- | \ | シャットダウンタイマーを停止する| \ rcv：シャットダウン| SHUTDOWN COMPLETEを送信| \（B）| TCBを削除します| \ | | \ | これ以上目立たない| \ | ----------------- | \ | SHUTDOWN ACK（B）rcv SHUTDOWNを送信します| \ | strtシャットダウンタイマー---------------------- | \ | シャットダウンACKを送信します| \ | シャットダウンタイマーを開始する| \ | SHUTDOWN- |に移動します \ | ACK-SENT | | | | v | | + ----------- + | | シャットダウン-| （7）| | ACK-SENT | | + ---------- +-| | （C）rcvシャットダウン完了| | ----------------- | | シャットダウンタイマーを停止する| | TCBを削除します| | | | （D）rcv シャットダウンACK | | -------------- | | シャットダウンタイマーを停止する| | SHUTDOWN COMPLETEを送信します| | TCBを削除します| | \ + --------- + / \-> | クローズ| <-/ + --------- +

図3：SCTPの状態遷移図 

ノート： 

1）受信したCOOKIE ECHOのState Cookieが無効な場合（つまり、整合性チェックに合格しなかった場合）、受信者は黙ってパケットを破棄する必要があります. または、受信した状態Cookieの有効期限が切れている場合（セクション5.1.5を参照）、受信者はERRORチャンクを返送する必要があります. どちらの場合でも、受信機はCLOSED状態のままです. 

2）T1-initタイマーが期限切れになった場合、エンドポイントはINITを再送信し、状態を変更せずにT1-initタイマーを再起動する必要があります. これは、「Max.Init.Retransmits」回まで繰り返されなければなりません. その後、エンドポイントは初期化プロセスを中止し、SCTPユーザーにエラーを報告する必要があります. 

3）T1-cookieタイマーが期限切れになった場合、エンドポイントはCOOKIE ECHOを再送信し、状態を変更せずにT1-cookieタイマーを再起動する必要があります. これは、「Max.Init.Retransmits」回まで繰り返されなければなりません. その後、エンドポイントは初期化プロセスを中止し、SCTPユーザーにエラーを報告する必要があります. 

4）SHUTDOWN-SENT状態では、エンドポイントは遅延なく受信したデータチャンクを確認する必要があります.  

5）SHUTDOWN-RECEIVED状態では、エンドポイントはSCTPユーザーからの新しい送信要求を受け入れてはなりません.  

6）SHUTDOWN-RECEIVED状態では、エンドポイントはデータを送信または再送信し、キュー内のすべてのデータが送信されたときにこの状態を終了する必要があります.  

7）SHUTDOWN-ACK-SENT状態では、エンドポイントはSCTPユーザーからの新しい送信要求を受け入れてはなりません.  

CLOSED状態は、関連付けが作成されていない（つまり、存在していない）ことを示すために使用されます.  

5.アソシエーションの初期化 

1つのSCTPエンドポイント（「A」）から別のSCTPエンドポイント（「Z」）への最初のデータ送信を行う前に、2つのエンドポイントは初期化プロセスを完了して、SCTPアソシエーションをセットアップする必要があります.  

エンドポイントのSCTPユーザーは、ASSOCIATEプリミティブを使用して、別のSCTPエンドポイントへのSCTPアソシエーションを初期化する必要があります.  

実装に関する注：SCTPユーザーの観点からは、最初のユーザーデータの宛先エンドポイントへの送信を開始するエンドポイントによって、ASSOCIATEプリミティブ（セクション10.1 Bを参照）を呼び出さずに、アソシエーションを暗黙的に開くことができます. 開始SCTPは、INIT / INIT ACKのすべての必須およびオプションパラメータのデフォルト値を想定します. 

関連付けが確立されると、両端でのデータ転送のために単方向ストリームが開かれます（セクション5.1.1を参照）.  

5.1. 協会の通常の設立

初期化プロセスは、次の手順で構成されます（SCTPエンドポイント「A」がSCTPエンドポイント「Z」との関連付けを設定しようとし、「Z」が新しい関連付けを受け入れたと仮定します） 

A）「A」は最初に「Z」にINITチャンクを送信します. INITでは、「A」は「タグを開始」フィールドに検証タグ（Tag_A）を提供する必要があります. Tag_Aは、1〜4294967295の範囲の乱数である必要があります（タグ値の選択については、セクション5.3.1を参照してください）. INITを送信した後、「A」はT1-initタイマーを開始し、COOKIE-WAIT状態に入ります. 

B）「Z」は、INIT ACKチャンクで即座に応答します. INIT ACKの宛先IPアドレスは、このINIT ACKが応答しているINITのソースIPアドレスに設定する必要があります. 応答では、他のパラメーターの入力に加えて、「Z」は検証タグフィールドをTag_Aに設定し、独自の検証タグ（Tag_Z）をタグ開始フィールドに提供する必要があります. 

さらに、「Z」はINIT ACKとともに状態Cookieを生成して送信する必要があります. 状態Cookieの生成については、セクション5.1.3を参照してください. 

注：State Cookieパラメーターを指定してINIT ACKを送信した後、「Z」はリソースを割り当てたり、新しい関連付けの状態を保持してはなりません（MUST NOT）. そうでない場合、「Z」はリソース攻撃に対して脆弱になります. 

C） "Z"からINIT ACKを受信すると、 "A"はT1- initタイマーを停止し、COOKIE-WAIT状態を離れます. 「A」は、COOKIE ECHOチャンクのINIT ACKチャンクで受信した状態Cookieを送信し、T1-Cookieタイマーを開始し、COOKIE-ECHOED状態に入ります. 

注：COOKIE ECHOチャンクは、保留中の発信DATAチャンクとバンドルできますが、パケットの最初のチャンクでなければならず、COOKIE A​​CKが返されるまで、送信者は他のパケットをピアに送信してはなりません（MUST NOT）.  

D）COOKIE ECHOチャンクを受信すると、エンドポイント「Z」はTCBを構築してESTABLISHED状態に移行した後、COOKIE A​​CKチャンクで応答します. COOKIE A​​CKチャンクは、保留中のDATAチャンク（および/またはSACKチャンク）にバンドルできますが、COOKIE A​​CKチャンクはパケットの最初のチャンクでなければなりません. 

実装注：実装は、有効なCOOKIE ECHOチャンクを受信すると、SCTPユーザーにCommunication Up通知を送信することを選択できます.  

E）COOKIE A​​CKを受信すると、エンドポイント「A」はCOOKIE-ECHOED状態からESTABLISHED状態に移行し、T1-Cookieタイマーを停止します. また、Communication Up通知との関連付けの確立が成功したことについてULPに通知する場合があります（セクション10を参照）. 

INITまたはINIT ACKチャンクを他のチャンクとバンドルしてはいけません. それらは、それらを運ぶSCTPパケットに存在する唯一のチャンクでなければなりません. 

エンドポイントは、INITを受信したIPアドレスにINIT ACKを送信する必要があります.  

注：T1-initタイマーとT1-cookieタイマーは、セクション6.3で与えられたのと同じ規則に従うものとします.  

エンドポイントがINIT、INIT ACK、またはCOOKIE ECHOチャンクを受信したが、受信したINITまたはINIT ACKの必須パラメーターの欠落、無効なパラメーター値、またはローカルリソースの不足により、新しい関連付けを確立しないことを決定した場合、 ABORTチャンク. また、ABORTチャンクにエラー原因パラメーターを含めることにより、欠落している必須パラメーターのタイプなど、アボートの原因を指定する必要があります. ABORTチャンクを含む発信SCTPパケットの共通ヘッダーの検証タグフィールドは、ピアの開始タグ値に設定する必要があります. 



整合性チェックに合格しないCOOKIE ECHOチャンクは「無効なパラメータ」とは見なされず、特別な処理が必要であることに注意してください. セクション5.1.5を参照してください. 

関連付けの最初のDATAチャンクの受信後、エンドポイントはすぐにSACKで応答して、DATAチャンクを確認する必要があります. セクション6.2で説明されているように、後続の確認を行う必要があります. 

TCBが作成されると、各エンドポイントは、その内部累積TSN Ackポイントを、送信された初期TSNから1を引いた値に設定しなければなりません.  

実装に関する注：IPアドレスとSCTPポートは、通常、SCTPインスタンス内でTCBを見つけるためのキーとして使用されます.  

5.1.1. ストリームパラメータの処理

INITおよびINIT ACKチャンクでは、チャンクの送信者は、アソシエーションに含めるアウトバウンドストリーム（OS）の数と、他のエンドポイントから受け入れる最大インバウンドストリーム（MIS）を示さなければなりません.  

反対側からストリーム構成情報を受信した後、各エンドポイントは次のチェックを実行する必要があります：ピアのMISがエンドポイントのOSよりも小さい場合、つまり、エンドポイントが構成したいすべてのアウトバウンドストリームをピアがサポートできないことを意味しますMISアウトバウンドストリームを使用する必要があり、不足があれば上位層に報告することができます. リソースの不足が許容できない場合、上位層は関連付けを中止することを選択できます. 

関連付けが初期化された後、いずれかのエンドポイントの有効なアウトバウンドストリーム識別子の範囲は0〜min（ローカルOS、リモートMIS）-1でなければなりません.  

5.1.2. アドレスパラメータの処理

アソシエーションの初期化中、エンドポイントは次のルールを使用して、ピアの宛先トランスポートアドレスを検出および収集します.  

A）受信したINITチャンクまたはINIT ACKチャンクにアドレスパラメーターが存在しない場合、エンドポイントは、チャンクの到着元のソースIPアドレスを取得し、SCTP送信元ポート番号と組み合わせて、唯一の宛先トランスポートアドレスとして記録します. このピアのために.  

B）受信したINITまたはINIT ACKチャンクにホスト名パラメーターが存在する場合、エンドポイントはそのホスト名をIPアドレスのリストに解決し、解決したものを組み合わせてこのピアのトランスポートアドレスを取得します.  SCTP送信元ポートのIPアドレス.  

エンドポイントは、受信したINITまたはINIT ACKチャンクにも他のIPアドレスパラメーターが存在する場合、それらを無視する必要があります.  

INITの受信者がホスト名を解決する時刻は、SCTPに潜在的なセキュリティの影響を与えます. INITの受信者がチャンクの受信時にホスト名を解決し、受信者がホスト名を解決するために使用するメカニズムに潜在的な長い遅延（DNSクエリなど）が含まれる場合、受信者はステートCookieを構築してローカルリソースを解放する前に、名前解決の結果を待機している期間. 

したがって、名前変換に潜在的な長い遅延が含まれる場合、INITの受信者は、ピアからのCOOKIE ECHOチャンクの受信まで名前解決を延期しなければなりません. そのような場合、INITの受信者は、（宛先トランスポートアドレスの代わりに）受信したホスト名を使用して状態Cookieを構築し、INITを受信したソースIPアドレスにINIT ACKを送信する必要があります. 

INIT ACKの受信者は、チャンクの受信時に常に即座に名前を解決しようとするものとします.  

INITまたはINIT ACKの受信者は、ホスト名が正常に解決されるまで、ピアにユーザーデータ（ピギーバックまたはスタンドアロン）を送信してはなりません（MUST NOT）.  

名前解決が成功しなかった場合、エンドポイントはすぐにピアに「Unresolvable Address」エラーの原因でABORTを送信する必要があります. ABORTは、最後のピアパケットを受信した送信元IPアドレスに送信されます. 

C）受信したINITまたはINIT ACKチャンクにIPv4 / IPv6アドレスのみが存在する場合、受信者は、受信したチャンクおよびINITまたはINIT ACKを送信したソースIPアドレスからすべてのトランスポートアドレスを導出および記録しなければなりません. トランスポートアドレスは、SCTP送信元ポート（共通ヘッダーから）、およびINITまたはINIT ACKチャンクで運ばれるIPアドレスパラメータとIPデータグラムの送信元IPアドレスの組み合わせによって導出されます. 受信者は、後続のパケットをピアに送信するときに、これらのトランスポートアドレスのみを宛先トランスポートアドレスとして使用する必要があります. D）INITまたはINIT ACKチャンクは、チャンク内に含まれる有効なアドレスパラメータのいずれかを使用して既存のTCBを識別する場合、既に確立されたアソシエーション（または確立中のアソシエーション）に属するものとして扱われなければなりません（MUST）. 

実装上の注意：場合によっては（たとえば、実装が送信に使用されるソースIPアドレスを制御しない場合）、エンドポイントはINITまたはINIT ACKに、ピアへのパケットが送信可能なすべてのIPアドレスを含める必要があります. 送信されます.  

上記のルールを使用してすべてのトランスポートアドレスがINITまたはINIT ACKチャンクから導出された後、エンドポイントはトランスポートアドレスの1つを初期プライマリパスとして選択します.  

注：INITの送信元アドレスにINIT ACKを送信する必要があります.  

INITの送信者は、受け入れ可能なアドレスのタイプを示すために、INITに「サポートされるアドレスタイプ」パラメータを含めることができます. このパラメーターが存在する場合、INIT（開始）の受信者は、INITに応答するときに、サポートされているアドレスタイプパラメーターに示されたアドレスタイプのいずれかを使用するか、「解決できないアドレス」エラー原因との関連付けを中止する必要がありますまたは、そのピアによって示されたアドレスタイプを使用できません. 

実装注：INIT ACKの受信者がサポートされていないタイプのためにアドレスパラメータを解決できない場合、開始プロセスを中止し、新しいINITで「サポートされているアドレスタイプ」パラメータを使用して再開始を試みることができます. 優先するアドレスの種類を示します.  

実装注：IPv4またはIPv6のいずれかのみをサポートするSCTPエンドポイントがピアからINITまたはINIT ACKチャンクでIPv4およびIPv6アドレスを受信する場合、サポートされるアドレスファミリに属する​​すべてのアドレスを使用する必要があります. 他のアドレスは無視される場合があります. エンドポイントは、いかなる種類のエラー表示でも応答すべきではありません. 

実装注：SCTPエンドポイントが「サポートされるアドレスタイプ」パラメーターにIPv4またはIPv6のいずれかをリストしているが、INITチャンクを含むパケットの送信に他のファミリーを使用する場合、またはINITチャンク内の他のファミリーのアドレスもリストする場合、次に、「サポートされるアドレスタイプ」パラメータにリストされていないアドレスファミリも、INITチャンクの受信者によってサポートされていると見なされる必要があります. INITチャンクの受信者は、あらゆる種類のエラー表示で応答すべきではありません. 



5.1.3. 状態クッキーの生成

INIT ACKへの応答としてINIT ACKを送信する場合、INIT ACKの送信者は状態Cookieを作成し、INIT ACKの状態Cookieパラメーターで送信します. この状態Cookieの内部では、送信者はMAC（例として[RFC2104]を参照）、状態Cookieが作成されたときのタイムスタンプ、状態Cookieの有効期間、およびそれを確立するために必要なすべての情報を含める必要があります協会. 

状態Cookieを生成するには、次の手順を実行する必要があります.  

1）受信したINITと発信INIT ACKチャンクの両方からの情報を使用して、アソシエーションTCBを作成します.  

2）TCBで、作成時刻を現在の時刻に設定し、寿命をプロトコルパラメーター「Valid.Cookie.Life」に設定します（セクション15を参照）.  

3）TCBから、TCBの再作成に必要な情報の最小限のサブセットを識別および収集し、この情報のサブセットと秘密鍵を使用してMACを生成します（MACの生成例については[RFC2104]を参照）.  

4）この情報のサブセットと結果のMACを組み合わせて、状態Cookieを生成します.  

State Cookieパラメータを指定してINIT ACKを送信した後、送信者は、リソース攻撃を防ぐために、TCBおよび新しい関連付けに関連する他のローカルリソースを削除する必要があります.  

MACの生成に使用されるハッシュ方法は、INITチャンクの受信者にとって厳密に個人的な問題です. サービス拒否攻撃を防ぐには、MACの使用が必須です. 秘密鍵はランダムである必要があります（[RFC4086]はランダム性ガイドラインに関する情報を提供します）. それは合理的に頻繁に変更されるべきであり（SHOULD）、ステートCookieのタイムスタンプを使用して、MACを検証するためにどのキーを使用するかを決定できます（MAY）. 

実装は、相互運用性を確保するためにCookieをできるだけ小さくする必要があります.  













5.1.4. 状態Cookie処理

（COOKIE-WAIT状態の）エンドポイントが状態Cookieパラメータを含むINIT ACKチャンクを受信すると、受信した状態Cookieを含むピアにCOOKIE ECHOチャンクを直ちに送信する必要があります. 送信者は、COOKIE ECHOチャンクの後に、保留中のDATAチャンクをパケットに追加することもできます. 

エンドポイントは、COOKIE ECHOチャンクを送信した後、T1-cookieタイマーも開始します. タイマーの期限が切れた場合、エンドポイントはCOOKIE ECHOチャンクを再送信し、T1-cookieタイマーを再起動する必要があります. これは、COOKIE A​​CKが受信されるか、「Max.Init.Retransmits」（セクション15を参照）に達するまで繰り返され、ピアエンドポイントが到達不能とマークされます（したがって、関連付けはCLOSED状態になります）. 

5.1.5. 状態Cookie認証

エンドポイントは、関連付けのない別のエンドポイントからCOOKIE ECHOチャンクを受信すると、次のアクションを実行します.  

1）状態Cookieに含まれるTCBデータと秘密鍵を使用してMACを計算します（状態Cookieのタイムスタンプを使用して、使用する秘密鍵を決定することができます）. [RFC2104]は、MACを生成するためのガイドラインとして使用できます. 

2）計算されたMACを状態Cookieで運ばれたMACと比較することにより、状態Cookieを以前に生成したものとして認証します. この比較が失敗した場合、COOKIE ECHOおよびDATAチャンクを含むSCTPパケットは静かに破棄されるべきです. 

3）COOKIE ECHOチャンクに含まれるポート番号と検証タグを、受信パケットのSCTP共通ヘッダー内の実際のポート番号と検証タグと比較します. これらの値が一致しない場合、パケットは静かに破棄されなければなりません. 

4）ステートCookieの作成タイムスタンプを現在の現地時間と比較します. 経過時間が状態Cookieで搬送される寿命よりも長い場合、COOKIE ECHOおよび添付されたDATAチャンクを含むパケットは破棄されるべきであり、エンドポイントは「Stale Cookie」エラーを含むERRORチャンクを送信する必要がありますピアエンドポイント. 





5）状態Cookieが有効な場合、COOKIE ECHOで運ばれるTCBデータの情報を使用してCOOKIE ECHOチャンクの送信者への関連付けを作成し、ESTABLISHED状態に入ります.  

6）COOKIE ECHOの受信を確認するピアにCOOKIE A​​CKチャンクを送信します. COOKIE A​​CKは、アウトバウンドDATAチャンクまたはSACKチャンクにバンドルされる場合があります. ただし、COOKIE A​​CKはSCTPパケットの最初のチャンクでなければなりません. 

7）COOKIE ECHOにバンドルされたDATAチャンクをSACKで即座に確認します（以降のDATAチャンク確認はセクション6.2で定義されたルールに従う必要があります）. ステップ6で述べたように、SACKがCOOKIE A​​CKにバンドルされている場合、COOKIE A​​CKはSCTPパケットの最初に現れなければなりません. 

COOKIE ECHOの受信者が既存の関連付けを持っているエンドポイントからCOOKIE ECHOを受信した場合、セクション5.2の手順に従う必要があります.  



























































5.1.6. 通常の協会設立の例

次の例では、「A」はアソシエーションを開始し、ユーザーメッセージを「Z」に送信し、その後「Z」は2つのユーザーメッセージを「A」に送信します（バンドリングまたはフラグメンテーションが発生しないと仮定）.  

エンドポイントAエンドポイントZ {アプリはZとの関連付けを設定}（TCBを構築）INIT [I-Tag = Tag_Aおよびその他の情報] ------ \（T1-initタイマーを開始）\（COOKIE-WAIT状態に入る）\- ->（temp TCBとCookie_Zを構成）/-INIT ACK [Veri Tag = Tag_A、/ I-Tag = Tag_Z、（T1-initタイマーをキャンセル）<------ / Cookie_Z、＆その他の情報]（ destroy temp TCB）COOKIE ECHO [Cookie_Z] ------ \（T1-initタイマーを開始）\（COOKIE-ECHOED状態に入る）\ --->（TCBを構築してESTABLISHED状態に入る）/ ---- COOKIE- ACK /（T1-initタイマーをキャンセル、<----- / ESTABLISHED状態に入る）{アプリが最初のユーザーデータを送信します. strm 0} DATA [TSN = initial TSN_A Strm = 0、Seq = 0＆user data]-\（T3-rtxタイマーを開始）\ \-> / ----- SACK [TSN Ack = init / TSN_A、Block = 0]（T3-rtxタイマーをキャンセル）<------ / ...

図4：初期化の例 



INITまたはCOOKIE ECHOチャンクが送信された後にT1-initタイマーが「A」で期限切れになった場合、同じInitiate Tag（つまり、Tag_A）またはState Cookieを持つ同じINITまたはCOOKIE ECHOチャンクが再送信され、タイマーが再起動されます. これはMax.Init.Retransmits回繰り返され、「A」が「Z」に到達できないと判断し、障害をその上位層に報告します（したがって、関連付けはCLOSED状態になります）. 

INITを再送信する場合、エンドポイントはセクション6.3で定義されたルールに従って、適切なタイマー値を決定する必要があります.  

5.2. 重複または予期しないINIT、INIT ACK、COOKIE ECHO、COOKIE A​​CKの処理

アソシエーションの有効期間中（可能な状態の1つ）、エンドポイントはピアエンドポイントからセットアップチャンク（INIT、INIT ACK、COOKIE ECHO、COOKIE A​​CK）のいずれかを受信する場合があります. 受信者は、このような設定チャンクを複製として扱い、このセクションで説明されているように処理します. 

注：チャンクがSCTPトランスポートアドレスに送信され、このエンドポイントに関連付けられたSCTPトランスポートアドレスからのものでない限り、エンドポイントはチャンクを受信しません. したがって、エンドポイントはそのようなチャンクを現在の関連付けの一部として処理します. 

次のシナリオは、重複したチャンクまたは予期しないチャンクを引き起こす可能性があります.  

A）ピアは検出されずにクラッシュし、それ自体を再起動し、関連付けを復元しようとして新しいINITチャンクを送信しました.  

B）両側が関連付けをほぼ同時に初期化しようとしている、 

C）チャンクは、現在のアソシエーションまたはもはや存在しない過去のアソシエーションを確立するために使用された古いパケットからのものです.  

D）チャンクが攻撃者によって生成された偽のパケット、または 

E）ピアはCOOKIE A​​CKを受信せず、COOKIE ECHOを再送信しています.  

これらのケースを識別して正しく処理するために、次のセクションのルールが適用されます.  









5.2.1. COOKIE-WAITまたはCOOKIE-ECHOED状態で受信されたINIT（アイテムB）

これは通常、初期化の衝突を示します. つまり、ほぼ同時に各エンドポイントが他のエンドポイントとのアソシエーションを確立しようとしています.  

COOKIE-WAIT状態でINITを受信すると、エンドポイントは、元のINITチャンク（変更されていない開始タグを含む）で送信したのと同じパラメータを使用して、INIT ACKで応答する必要があります. 応答するとき、エンドポイントは元のINIT（このエンドポイントによって送信された）が送信されたのと同じアドレスにINIT ACKを返送しなければなりません. 

COOKIE-ECHOED状態でINITを受信すると、エンドポイントは、新しいアドレスが追加されていない場合、元のINITチャンク（変更されていない開始タグを含む）で送信したのと同じパラメータを使用してINIT ACKで応答する必要があります形成協会. INITメッセージが新しいアドレスがアソシエーションに追加されたことを示している場合、INIT全体を破棄しなければならず、既存のアソシエーションに変更を加えることはできません. ABORTは、「新しいアドレスとの関連付けの再開」というエラーを含む場合があります. エラーは、再起動するアソシエーションに追加されたアドレスをリストする必要があります. 

INIT ACKでいずれかの状態（COOKIE-WAITまたはCOOKIE-ECHOED）で応答する場合、元のパラメーターは新しく受信したINITチャンクからのパラメーターと結合されます. エンドポイントは、INIT ACKで状態Cookieも生成します. エンドポイントは、INITで送信されたパラメーターを使用して、状態Cookieを計算します. 

その後、エンドポイントの状態を変更してはならず、T1-initタイマーは実行したままにして、対応するTCBを破棄してはなりません. TCBが存在するときに状態Cookieを処理する通常の手順では、重複したINITが単一の関連付けに解決されます. 

COOKIE-ECHOED状態にあるエンドポイントの場合、アソシエーションTCBとState Cookieの両方にTie-Tagを入力する必要があります（Tie-Tagの説明についてはセクション5.2.2を参照してください）.  

5.2.2. CLOSED、COOKIE-ECHOED、COOKIE-WAIT、およびSHUTDOWN-ACK-SENT以外の状態での予期しないINIT

特に明記しない限り、このアソシエーションの予期しないINITを受信すると、エンドポイントは状態CookieでINIT ACKを生成します. 応答する前に、エンドポイントは予期しないINITが関連付けに新しいアドレスを追加するかどうかを確認する必要があります. 新しいアドレスが関連付けに追加される場合、エンドポイントはABORTで応答し、予期しないINITの「Initiate Tag」をABORTを送信するアウトバウンドパケットの「Verification Tag」にコピーする必要があります. ABORT応答では、エラーの原因を「新しいアドレスとの関連付けの再開」に設定することができます. エラーは、再起動するアソシエーションに追加されたアドレスをリストする必要があります. 新しいアドレスが追加されない場合、アウトバウンドINIT ACKのINITに応答するときに、エンドポイントは、現在のTie-TagsをState CookieとアソシエーションのTCB内の予約された場所にコピーしなければなりません. Cookie内のこれらの場所を、Peer's-Tie-TagおよびLocal-Tie-Tagと呼びます. アソシエーションのTCB内のコピーをローカルタグおよびピアのタグと呼びます. このINIT ACKを含むアウトバウンドSCTPパケットは、予期しないINITで見つかった開始タグと等しい検証タグ値を運ばなければなりません. そして、INIT ACKには、新しい開始タグ（ランダムに生成された. セクション5.3.1を参照）が含まれていなければなりません. エンドポイントの他のパラメータは、アソシエーションの既存のパラメータ（アウトバウンドストリームの数など）からINIT ACKおよびCookieにコピーする必要があります（SHOULD）. アソシエーションのTCB内のコピーをローカルタグおよびピアのタグと呼びます. このINIT ACKを含むアウトバウンドSCTPパケットは、予期しないINITで見つかった開始タグと等しい検証タグ値を運ばなければなりません. そして、INIT ACKには、新しい開始タグ（ランダムに生成された. セクション5.3.1を参照）が含まれていなければなりません. エンドポイントの他のパラメータは、アソシエーションの既存のパラメータ（アウトバウンドストリームの数など）からINIT ACKおよびCookieにコピーする必要があります（SHOULD）. アソシエーションのTCB内のコピーをローカルタグおよびピアのタグと呼びます. このINIT ACKを含むアウトバウンドSCTPパケットは、予期しないINITで見つかった開始タグと等しい検証タグ値を運ばなければなりません. そして、INIT ACKには、新しい開始タグ（ランダムに生成された. セクション5.3.1を参照）が含まれていなければなりません. エンドポイントの他のパラメータは、アソシエーションの既存のパラメータ（アウトバウンドストリームの数など）からINIT ACKおよびCookieにコピーする必要があります（SHOULD）. 

INIT ACKまたはABORTを送信した後、エンドポイントはそれ以上のアクションを実行しません. つまり、現在の状態を含む既存の関連付け、および対応するTCBを変更してはなりません. 

注：TCBが存在し、関連付けがCOOKIE-WAITまたはSHUTDOWN-ACK-SENT状態でない場合にのみ、タイタグに0以外の値が入力されます. 通常の関連付けINIT（つまり、エンドポイントはCLOSED状態）、Tie-Tagsは0に設定する必要があります（以前のTCBが存在しなかったことを示します）.  

5.2.3. 予期しないINIT ACK

COOKIE-WAIT状態以外の状態のエンドポイントがINIT ACKを受信した場合、エンドポイントはINIT ACKチャンクを破棄する必要があります. 通常、予期しないINIT ACKは、古いまたは重複したINITチャンクの処理を示します. 

5.2.4. TCBが存在するときにCOOKIE ECHOを処理する

COOKIE ECHOチャンクが、既存のアソシエーションのいずれかの状態（つまり、CLOSED状態ではない）でエンドポイントによって受信されると、次の規則が適用されます.  

1）セクション5.1.5のステップ1の説明に従ってMACを計算します.  

2）セクション5.1.5のステップ2で説明されているように、状態Cookieを認証します（これは上記のケースCまたはDです）.  

3）ステートCookieのタイムスタンプを現在の時刻と比較します. 状態Cookieが状態Cookieに含まれる有効期限よりも古く、状態Cookieに含まれる検証タグが現在の関連付けの検証タグと一致しない場合、COOKIE ECHOおよびDATAチャンクを含むパケットは破棄する必要があります. エンドポイントは、ピアエンドポイントに「Stale Cookie」エラーの原因を持つERRORチャンクも送信する必要があります（これはセクション5.2のCまたはDのケースです）. 

状態Cookieの両方の検証タグが現在のアソシエーションの検証タグと一致する場合、寿命が超過しても状態Cookieが有効であると見なします（これはセクション5.2のケースEです）.  

4）ステートCookieが有効であることが判明した場合、TCBを一時的なTCBに解凍します.  

5）表2を参照して、実行する正しいアクションを決定します.  

+ ------------ + ------------ + --------------- + ------- ------- + ------------- + | ローカルタグ| ピアのタグ| ローカルタイタグ|ピア s-tie-tag | アクション/ | | | | | | 説明| + ------------ + ------------ + --------------- + ------- ------- + ------------- + | X | X | M | M | （A）| + ------------ + ------------ + --------------- + ------- ------- + ------------- + | M | X | A | A | （B）| + ------------ + ------------ + --------------- + ------- ------- + ------------- + | M | 0 | A | A | （B）| + ------------ + ------------ + --------------- + ------- ------- + ------------- + | X | M | 0 | 0 | （C）| + ------------ + ------------ + --------------- + ------- ------- + ------------- + | M | M | A | A | （D）| + ================================================ ===================== + | 表2：TCBが存在する場合のCOOKIE ECHOの処理| + ================================================ ===================== +

伝説： 

X-タグは既存のTCBと一致しません. M-タグは既存のTCBと一致します. 0-Cookieにタイタグがありません（不明）. A-すべてのケース、つまり、M、X、または0. 

注：表2に示されていない場合は、Cookieを静かに破棄する必要があります.  

アクション 

A）この場合、ピアが再起動した可能性があります. エンドポイントがこの潜在的な「再起動」を認識すると、既存のセッションは、次の例外を除き、ABORTに続いて新しいCOOKIE ECHOを受信した場合と同じように扱われます：-SCTP DATAチャンクは保持される場合があります（これは実装固有のオプションです）. 

-「COMMUNICATION LOST」通知の代わりに、再起動の通知をULPに送信する必要があります.  

このピアに関連するすべての輻輳制御パラメータ（cwnd、ssthreshなど）は、初期値にリセットする必要があります（セクション6.2.1を参照）.  

この後、エンドポイントはESTABLISHED状態に入ります.  

エンドポイントがSHUTDOWN-ACK-SENT状態にあり、ピアが再起動したことを認識する場合（アクションA）、エンドポイントは新しい関連付けを設定してはならず、代わりにSHUTDOWN ACKを再送信し、「Cookie Received while Shutingピアにダウン」エラーの原因.  

B）この場合、両側がほぼ同時にアソシエーションを開始しようとしている可能性がありますが、ピアエンドポイントはローカルエンドポイントのINITに応答した後にINITを開始しました. したがって、このエンドポイントを送信した以前のタグを認識せずに、新しい検証タグを選択した可能性があります. エンドポイントはESTABLISHED状態のままになるか、ESTABLISHED状態に入る必要がありますが、ピアの検証タグを状態Cookieから更新し、実行中のinitまたはCookieタイマーを停止して、COOKIE A​​CKを送信する必要があります. 

C）この場合、ローカルエンドポイントのCookieが遅れて到着しています. 到着する前に、ローカルエンドポイントはINITを送信し、INIT ACKを受信し、最終的にピアの同じタグで独自の新しいタグを含むCOOKIE ECHOを送信しました. Cookieは静かに破棄する必要があります. エンドポイントは状態を変更すべきではなく（SHOULD NOT）、タイマーを実行したままにする必要があります. 

D）ローカルタグとリモートタグの両方が一致する場合、エンドポイントは、COOKIE-ECHOED状態にある場合、ESTABLISHED状態に入る必要があります. 実行中のCookieタイマーを停止し、COOKIE A​​CKを送信する必要があります. 

注：「ピアの検証タグ」は、INITまたはINIT ACKチャンクのInitiate Tagフィールドで受信したタグです.  

5.2.4.1. アソシエーションの再起動の例

次の例では、再起動後に「A」が関連付けを開始します. エンドポイント「Z」は、交換が行われるまで再起動を認識しませんでした（つまり、ハートビートが「A」の障害をまだ検出していません）（バンドリングまたはフラグメンテーションが発生しないと仮定）：エンドポイントAエンドポイントZ <-------- ------関連付けが確立されました----------------------> Tag = Tag_A Tag = Tag_Z <----------- -------------------------------------------------- -> {Aがクラッシュして再起動します} {アプリはZとの関連付けを設定します}（TCBを作成）INIT [I-Tag = Tag_A 'およびその他の情報] -------- \（T1-initタイマーを開始） \（COOKIE-WAIT状態に入る）\ ---> （既存のTCBを作成し、以前のアソシエーションにTie-Tagsで一時TCBとCookie_Zを作成します）/ --- INIT ACK [Veri Tag = Tag_A '、/ I-Tag = Tag_Z'、（T1-initタイマーをキャンセル）<--- --- / Cookie_Z [TieTags = Tag_A、Tag_Z＆その他の情報]（一時TCBを破棄し、元の場所に残します）COOKIE ECHO [Veri = Tag_Z '、Cookie_Z Tie = Tag_A、Tag_Z] ---------- \（T1-initタイマーを開始する）\（COOKIE-ECHOED状態に入る）\ --->（既存の関連付けを見つける、タイタグが古いタグと一致する、タグが一致しない、つまり、上記のケースXXMM、再起動をULPに通知してリセットする協会）. / ---- COOKIE A​​CK（T1-initタイマーをキャンセル、<------ / ESTABLISHED状態に入る）{アプリが最初のユーザーデータを送信します. strm 0} DATA [TSN = initial TSN_A Strm = 0、Seq = 0＆user data]-\（T3-rtxタイマーを開始）\ \-> / --- SACK [TSN Ack = init TSN_A、

図5：再起動の例 







5.2.5. 重複したCOOKIE-ACKを処理します. 

COOKIE-ECHOED以外の状態では、エンドポイントは受信したCOOKIE A​​CKチャンクを静かに破棄する必要があります.  

5.2.6. 古いCOOKIEエラーの処理

「Stale Cookie」エラーの原因を持つERRORチャンクの受信は、考えられるいくつかのイベントの1つを示します.  

A）送信者が発行した状態Cookieが処理される前に、関連付けを完全にセットアップできませんでした.  

B）セットアップの完了後に古い状態のCookieが処理されました.  

C）受信者がアソシエーションを持つことに興味がなく、ABORTチャンクが失われた誰かから古い状態Cookieを受信した.  

「Stale Cookie」エラーが発生したERRORチャンクを処理する場合、エンドポイントは最初に関連付けがセットアップ中かどうか、つまり関連付けがCOOKIE-ECHOED状態にあるかどうかを調べる必要があります. すべての場合において、関連付けがCOOKIE-ECHOED状態にない場合、ERRORチャンクは静かに破棄される必要があります. 

アソシエーションがCOOKIE-ECHOED状態にある場合、エンドポイントは次の3つの選択肢のいずれかを選択できます.  

1）新しいINITチャンクをエンドポイントに送信して、新しい状態Cookieを生成し、セットアップ手順を再試行します.  

2）TCBを破棄し、関連付けを設定できないことを上位層に報告します.  

3）新しいINITチャンクをエンドポイントに送信し、状態Cookieの有効期間の延長を要求するCookie Preservativeパラメーターを追加します. 延長時間を計算するとき、実装は以前のCOOKIE ECHO / ERROR交換に基づいて測定されたRTT情報を使用する必要があります. また、状態Cookieのライフタイムが長いためエンドポイントがより影響を受けやすくなるため、測定されたRTTを1秒以内に追加する必要がありますリプレイ攻撃. 













5.3. その他の初期化の問題

5.3.1. タグ値の選択

開始タグの値は、1〜2 ** 32-1の範囲から選択する必要があります. 開始タグの値をランダム化して、「中間者」攻撃と「シーケンス番号」攻撃から保護することが非常に重要です. [RFC4086]で説明されている方法は、タグのランダム化の開始に使用できます. 開始タグの慎重な選択は、以前のアソシエーションからの古い重複パケットが現在のアソシエーションに属していると誤って処理されるのを防ぐためにも必要です. 

さらに、特定の関連付けのいずれかのエンドポイントで使用される検証タグの値は、関連付けの存続期間中に変更してはなりません. エンドポイントが破棄され、同じピアへの関連付けを再確立するたびに、新しい検証タグ値を使用する必要があります. 

5.4. パス検証

アソシエーションの確立中に、2つのピアはアドレスのリストを交換します. 主な場合、これらのリストは各ピアが所有するアドレスを正確に表します. ただし、不正な動作をしているピアが、所有していないアドレスを提供する可能性があります. これを防ぐため、新しい関連付けのすべてのアドレスに次のルールが適用されます. 

1）上位層によってINITの送信者に渡されるアドレスは、自動的に確認済みと見なされます.  

2）COOKIE ECHOの受信者の場合、唯一の確認済みアドレスはINIT-ACKの送信先アドレスです.  

3）ルール1および2でカバーされていない他のすべてのアドレスは未確認と見なされ、検証のための調査の対象となります.  

検証のためにアドレスをプローブするために、エンドポイントは、HEARTBEATパラメーター内で64ビットランダムナンスとパスインジケーター（HEARTBEATの送信先アドレスを識別するため）を含むHEARTBEATを送信します.  

HEARTBEAT ACKを受信すると、HEARTBEATパラメーターに含まれるナンスが、HEARTBEATパラメーター内に示されたアドレスに送信されたナンスであることを確認します. この一致が発生すると、元のHEARTBEATが送信されたアドレスは確認済みと見なされ、通常のデータ転送に使用できるようになります. 

これらのプローブ手順は、関連付けがESTABLISHED状態に移行すると開始され、すべてのパスが確認されると終了します.  

各RTOで、プローブをCONFIRMED状態に移行するために、アクティブなUNCONFIRMEDパスでプローブを送信できます. この調査中にパスが非アクティブになると、このレートは通常のハートビートレートまで低下します. RTOタイマーの有効期限が切れると、プローブされたがCONFIRMEDでないパスのエラーカウンターが1増加し、セクション8.2で定義されているように、パス障害検出の対象となります. ただし、UNCONFIRMEDアドレスをプローブする場合、アソシエーション全体のエラーカウントは増加しません. 

各RTOで送信されるHEARTBEATSの数は、HB.Max.Burstパラメーターによって制限される必要があります. これは、パス検証のためにHEARTBEATSをピアのアドレスに配布する方法に関する実装上の決定です. 

パスが確認されるたびに、上位層に指示が与えられる場合があります.  

エンドポイントは、次の例外を除き、未確認のアドレスにチャンクを送信してはなりません.  

-ノンスを含むハートビートは、未確認のアドレスに送信される場合があります.  

-ハートビートACKは未確認のアドレスに送信される場合があります.  

-COOKIE A​​CKは未確認のアドレスに送信できますが、ノンスを含むHEARTBEATにバンドルする必要があります. バンドリングをサポートしない実装は、未確認のアドレスにCOOKIE A​​CKを送信してはなりません. 

-COOKIE ECHOは未確認のアドレスに送信できますが、ノンスを含むHEARTBEATにバンドルする必要があり、パケットがパスMTUを超えてはなりません. 実装がバンドリングをサポートしない場合、またはバンドルされたCOOKIE ECHOとHEARTBEAT（nonceを含む）がパスMTUを超える場合、実装は未確認のアドレスにCOOKIE ECHOを送信してはなりません. 

6.ユーザーデータ転送 

データ送信は、ESTABLISHED、SHUTDOWN- PENDING、およびSHUTDOWN-RECEIVED状態でのみ発生する必要があります. これの唯一の例外は、COOKIE-WAIT状態の場合、DATAチャンクを発信COOKIE ECHOチャンクにバンドルできることです. 



データチャンクは、以下のESTABLISHED、SHUTDOWN-PENDING、およびSHUTDOWN-SENTのルールに従ってのみ受信する必要があります. CLOSEDで受信したDATAチャンクは青く、セクション8.4に従って処理する必要があります. 他の状態で受信したDATAチャンクは破棄する必要があります. 

SACKは、ESTABLISHED、SHUTDOWN-PENDING、およびSHUTDOWN-RECEIVEDで処理する必要があります. 着信SACKはCOOKIE-ECHOEDで処理される場合があります. CLOSED状態のSACKは青色ではなく、セクション8.4のルールに従って処理される必要があります. 他の状態で受信したSACKチャンクは破棄する必要があります. 

SCTP受信者は、1つのSCTPパケットで最低1500バイトを受信できなければなりません. これは、SCTPエンドポイントが、INITまたはINIT ACKで送信された最初のa_rwndで1500バイト未満を示してはならないことを意味します. 

伝送効率のために、SCTPは小さなユーザーメッセージのバンドルと大きなユーザーメッセージの断片化のメカニズムを定義します. 次の図は、SCTPを介したユーザーメッセージのフローを示しています. 

このセクションでは、「データ送信者」という用語は、DATAチャンクを送信するエンドポイントを指し、「データ受信者」という用語は、DATAチャンクを受信するエンドポイントを指します. データ受信者はSACKチャンクを送信します. 













































+ -------------------------- + | ユーザーメッセージ| + -------------------------- + SCTPユーザー^ | ================== | == | ============================ =========== | v（1）+ ------------------ + + -------------------- + | SCTPデータチャンク| | SCTPコントロールチャンク| + ------------------ + + -------------------- + ^ | ^ | | v（2）| v（2）+ -------------------------- + | SCTPパケット| + -------------------------- + SCTP ^ | =========================== | == | =================== ======== | vコネクションレスパケット転送サービス（IPなど）

ノート： 

1）ユーザーメッセージをDATAチャンクに変換する場合、エンドポイントは現在の関連付けパスMTUよりも大きいユーザーメッセージを複数のDATAチャンクに断片化します. データ受信者は、通常、ユーザーに配信する前に、DATAチャンクから断片化されたメッセージを再構成します（詳細については、セクション6.9を参照）. 

2）パケットの最終サイズが現在のパスMTUを超えない限り、送信者は複数のDATAおよび制御チャンクを送信用に単一のSCTPパケットにバンドルできます. 受信者は、パケットを元のチャンクに戻します. 制御チャンクは、パケット内のDATAチャンクの前に来る必要があります. 

図6：ユーザーデータ転送の図 

セクション6.9およびセクション6.10で詳述するフラグメンテーションおよびバンドリングメカニズムは、データ送信者が実装するオプションですが、データ受信者が実装する必要があります. つまり、エンドポイントはバンドルまたはフラグメント化されたデータを適切に受信および処理する必要があります.  

6.1. データチャンクの送信

このドキュメントは、あて先トランスポートアドレスごとに単一の再送信タイマーがあるかのように指定されていますが、実装は各DATAチャンクに対して再送信タイマーを持つことができます.  



データ送信者は、アウトバウンドDATAチャンクの送信および/または再送信のために、次の一般的な規則を適用する必要があります.  

A）いつでも、ピアのrwndがピアにバッファスペースがないことを示す場合（つまり、rwndが0、セクション6.2.1を参照）、データ送信者は新しいデータを宛先トランスポートアドレスに送信してはなりません. ただし、rwndの値（0の場合を含む）に関係なく、cwndで許可されている場合、データ送信側は受信側への1つのDATAチャンクを常に保持できます（以下のルールBを参照）. このルールにより、送信者は、データ受信者からデータ送信者への送信中にSACKが失われたために送信者が見逃したrwndの変化を調べることができます. 

レシーバのアドバタイズされたウィンドウがゼロの場合、このプローブはゼロウィンドウプローブと呼ばれます. ゼロウィンドウプローブは、すべての未処理のDATAチャンクが累積的に確認され、DATAチャンクが飛行中でない場合にのみ送信される必要があることに注意してください. ゼロウィンドウプローブをサポートする必要があります. 

送信者がゼロウィンドウプローブを実行している間、受信者から新しいパケットを受信し続ける場合、未確認ウィンドウプローブは、アソシエーションまたは任意の宛先トランスポートアドレスのエラーカウンターをインクリメントしません. これは、レシーバがウィンドウを無期限に閉じたままにすることができるためです. ゼロウィンドウをアドバタイズするときのレシーバの動作については、セクション6.2を参照してください. 送信者は、受信者がウィンドウを閉じたことを検出すると、1 RTOの後に最初のゼロウィンドウプローブを送信する必要があり（SHOULD）、その後、プローブ間隔を指数関数的に増加させる必要があります. また、セクション7.2.1に従ってcwndを調整する必要があることに注意してください. ゼロウィンドウプローブは、cwndの計算に影響しません. 

また、送信者は、[RFC0813]で説明されているように、愚かなウィンドウ症候群（SWS）を回避するために、新しいDATAチャンクを送信するためのアルゴリズムを持たなければなりません. アルゴリズムは、[RFC1122]のセクション4.2.3.4で説明されているものと類似しています. 

ただし、rwndの値（0の場合を含む）に関係なく、cwndで許可されている場合、データ送信側は常に1つのDATAチャンクを受信側に送信できます（以下のルールBを参照）. このルールにより、送信者は、データ受信者からデータ送信者への送信中にSACKが失われたために送信者が見逃したrwndの変更を調べることができます. 

B）任意の時点で、送信者は、そのトランスポートアドレスに対してcwnd以上のバイトのデータが残っている場合、新しいデータを特定のトランスポートアドレスに送信してはなりません.  



C）送信者が送信する時が来たら、新しいDATAチャンクを送信する前に、送信者は最初に、再送信用にマークされた未処理のDATAチャンクを送信しなければなりません（現在のcwndによって制限されます）.  

D）送信者が新しいDATAチャンクを送信するときが来たら、プロトコルパラメータMax.Burstを使用して、送信されるパケットの数を制限する必要があります. 次のようにcwndを調整することにより、制限を適用できます. 

if（（flightsize + Max.Burst * MTU）<cwnd）cwnd = Flightsize + Max.Burst * MTU 

または、出力ルーチンによって放出されるパケットの数を厳密に制限することにより適用できます.  

E）次に、送信者はルールAとルールBが許可する数の新しいDATAチャンクを送信できます.  

送信のためにコミットされた複数のデータチャンクは、単一のパケットにバンドルされる場合があります. さらに、再送信されるDATAチャンクは、結果のパケットサイズがパスMTUを超えない限り、新しいDATAチャンクにバンドルされる場合があります. ULPは、バンドリングの実行を要求しない場合がありますが、これは、SCTP実装がバンドリング効率を高めるために使用している遅延のみをオフにする必要があります. それ自体では、すべてのバンドリングの発生を停止しません（つまり、輻輳または再送信の場合）. 

エンドポイントがDATAチャンクを送信する前に、受信したDATAチャンクが確認されない場合（たとえば、遅延ACKにより）、送信者はSACKを作成し、最終SCTPのサイズである限り、送信DATAチャンクにバンドルする必要がありますパケットは現在のMTUを超えません. セクション6.2を参照してください. 

実装注：ウィンドウがいっぱいの場合（つまり、ルールAおよび/またはルールBによって送信が許可されない場合）、送信者は上位層からの送信要求を受け入れてもかまいませんが、未処理の一部またはすべてまでデータチャンクを送信してはなりませんデータチャンクは確認され、ルールAとルールBによって再び送信が許可されます.  

任意のアドレスに送信または再送信が行われるたびに、そのアドレスのT3-rtxタイマーが現在実行されていない場合、送信者はそのタイマーを開始する必要があります. そのアドレスのタイマーが既に実行されている場合、そのアドレスに送信された最も早い（つまり、最も低いTSN）未処理のデータチャンクが再送信されている場合、送信者はタイマーを再起動しなければなりません. そうでない場合、データ送信者はタイマーを再起動してはいけません. 

T3-rtxタイマーを開始または再起動する場合、セクション6.3.2および6.3.3で定義されているタイマールールに従ってタイマー値を調整する必要があります.  

注：データ送信者は、現在の送信ウィンドウの開始TSNより2 ** 31-1を超えるTSNを使用しないでください.  

6.2. データチャンクの受信に関する謝辞

SCTPエンドポイントは、受信したDATAチャンクが受信ウィンドウ内にある場合、各有効なDATAチャンクの受信を常に確認する必要があります.  

受信者のアドバタイズされたウィンドウが0の場合、受信者は、これまでに受信した最大のTSNよりも大きいTSNを持つ新しい着信DATAチャンクをドロップしなければなりません. 新しい着信DATAチャンクがこれまでに受信した最大のTSNより小さいTSN値を保持している場合、受信者は並べ替えのために保持されている最大のTSNをドロップし、新しい着信DATAチャンクを受け入れる必要があります. いずれの場合でも、そのようなDATAチャンクがドロップされた場合、受信者はすぐにSACKを返さなければならず、現在の受信ウィンドウはこれまでに受信および受け入れられたDATAチャンクのみを表示します. ドロップされたDATAチャンクは、受け入れられなかったため、SACKに含めることはできません. [RFC0813]で説明されているように、受信者は受信者の愚かなウィンドウ症候群（SWS）を避けるために、受信ウィンドウを通知するアルゴリズムも持たなければなりません（MUST）. アルゴリズムは、セクション4.2.3で説明されているものと類似しています. 

[RFC2581]のセクション4.2で指定された遅延確認応答アルゴリズムに関するガイドラインに従う必要があります. 具体的には、少なくとも2番目のパケット（すべてのDATAチャンクではない）が受信されるたびに確認応答が生成される必要があり（SHOULD）、未確認のDATAチャンクの到着から200ミリ秒以内に生成される必要があります. 状況によっては、SCTPトランスミッタがこのドキュメントで詳述されているアルゴリズムが許可するよりも保守的であることが有益な場合があります. ただし、SCTP送信機は、次のアルゴリズムが許可するよりも積極的であってはなりません. 

SCTP受信機は、受信アプリケーションが新しいデータを消費するときに提供されるウィンドウを更新する場合を除き、すべての着信パケットに対して複数のSACKを生成してはなりません.  

実装に関する注：送達されるプロトコルの特定のタイミング要件を満たすために、確認を生成するための最大遅延をSCTP管理者が静的または動的に設定できます. 

実装では、最大遅延を500ミリ秒以上に設定することを許可してはなりません. 言い換えれば、実装はこの値を500ミリ秒未満に下げることができますが、500ミリ秒を超えてはなりません. ULPがシャットダウンを要求しない限り、SACKチャンクで確認応答を送信する必要があります. その場合、エンドポイントはSHUTDOWNチャンクで確認応答を送信できます. SACKチャンクは、複数のDATAチャンクの受信を確認できます. SACKチャンク形式については、セクション3.3.4を参照してください. 特に、SCTPエンドポイントは、累積TSN Ackフィールドに入力して、受信した（有効なDATAチャンクの）最新の順次TSNを示す必要があります. TSNが累積TSN Ackフィールドの値よりも大きい受信DATAチャンクは、Gap Ack Blockフィールドで報告されます. 

注：SHUTDOWNチャンクにはGap Ack Blockフィールドは含まれません. したがって、エンドポイントは、順不同で受信したDATAチャンクを確認するために、SHUTDOWNチャンクの代わりにSACKを使用する必要があります. 

パケットが重複したDATAチャンクで到着し、新しいDATAチャンクで到着しない場合、エンドポイントは即座に遅延なくSACKを送信する必要があります. 新しいDATAチャンクにバンドルされた重複したDATAチャンクでパケットが到着した場合、エンドポイントはすぐにSACKを送信できます. 通常、元のSACKチャンクが失われ、ピアのRTOの有効期限が切れると、重複したDATAチャンクの受信が発生します. 重複したTSN番号は、SACKで重複として報告される必要があります. 

エンドポイントがSACKを受信すると、重複したTSN情報を使用して、SACKの損失が発生しているかどうかを判断する場合があります. このデータのさらなる使用は、将来の研究のためです. 

データ受信者は、受信バッファを維持する責任があります. データ受信者は、データを受信する能力の変化をタイムリーにデータ送信者に通知する必要があります. 実装が受信バッファを管理する方法は、多くの要因（オペレーティングシステム、メモリ管理システム、メモリ量など）に依存します. ただし、セクション6.2.1で定義されているデータ送信者戦略は、次のような受信者操作の仮定に基づいています. 

A）アソシエーションの初期化時に、エンドポイントはピアに、INITまたはINIT ACKでアソシエーションに割り当てた受信バッファスペースを通知します. エンドポイントはa_rwndをこの値に設定します. 

B）DATAチャンクが受信およびバッファリングされると、受信およびバッファリングされたバイト数だけa_rwndをデクリメントします. これは、実際には、データ送信側でrwndを閉じ、送信できるデータの量を制限します. 







C）DATAチャンクがULPに配信され、受信バッファから解放されると、a_rwndを上位層に配信されたバイト数だけインクリメントします. これは、実際には、データ送信側でrwndを開き、より多くのデータを送信できるようにします. データ受信者は、受信バッファからバイトを解放しない限り、a_rwndをインクリメントすべきではありません. たとえば、レシーバーが断片化されたDATAチャンクをリアセンブリキューに保持している場合、a_rwndをインクリメントしないでください. 

D）SACKを送信する場合、データ受信者はa_rwndの現在の値をa_rwndフィールドに配置する必要があります. データ受信者は、データ送信者が累積TSN ACKを介して確認応答されたDATAチャンクを再送信しない（つまり、再送信キューからドロップする）ことを考慮すべきである（SHOULD）. 

特定の状況では、データ受信者は、受信したが受信バッファーから解放されていない（つまり、ULPに配信された）DATAチャンクをドロップする必要がある場合があります. これらのデータチャンクは、ギャップAckブロックで確認された可能性があります. たとえば、データレシーバーは、受信バッファスペースを使い果たしたときに、ピアからの断片化されたユーザーメッセージを再構成しながら、受信バッファにデータを保持している場合があります. Gap Ack Blocksで確認したにもかかわらず、これらのDATAチャンクをドロップする場合があります. データ受信者がDATAチャンクをドロップする場合、再送信を介して再び受信されるまで、後続のSACKのGap Ackブロックにそれらを含めてはなりません. さらに、エンドポイントは、a_rwndを計算するときに、ドロップされたデータを考慮する必要があります. 

エンドポイントは、SACKを取り消してデータを破棄するべきではありません. 極端な状況でのみ、エンドポイントはこの手順を使用する必要があります（バッファ領域不足など）. データ受信者は、Gap Ack Blocksで確認されたデータをドロップすると、データ送信者の再送信戦略が最適ではなくなり、パフォーマンスが最適化されないことを考慮する必要があります. 





























次の例は、遅延確認応答の使用を示しています.  

エンドポイントAエンドポイントZ 

{アプリは3つのメッセージを送信します. strm 0} DATA [TSN = 7、Strm = 0、Seq = 3] ------------>（ack delay）（T3-rtxタイマーを開始）

データ[TSN = 8、Strm = 0、Seq = 4] ------------>（ackを送信）/ ------- SACK [TSN Ack = 8、block = 0] （T3-rtxタイマーをキャンセル）<----- / 

DATA [TSN = 9、Strm = 0、Seq = 5] ------------>（ack delay）（Start T3-rtx timer）... {App send 1 message; strm 1}（DATA付きバンドルSACK）/ ----- SACK [TSN Ack = 9、block = 0] \ / DATA [TSN = 6、Strm = 1、Seq = 2]（T3-rtxタイマーをキャンセル）< ------ /（T3-rtxタイマーを開始）

（ack遅延）（ackを送信）SACK [TSN Ack = 6、block = 0] ------------->（T3-rtxタイマーをキャンセル） 

図7：遅延確認応答の例 

エンドポイントがユーザーデータなしでDATAチャンクを受信した場合（つまり、長さフィールドが16に設定されている場合）、エラー原因が「ユーザーデータなし」に設定されたABORTを送信する必要があります.  

エンドポイントは、ユーザーデータ部分のないDATAチャンクを送信すべきではありません.  

6.2.1. 受信したSACKの処理

エンドポイントが受信する各SACKには、a_rwnd値が含まれています. この値は、SACKの送信時にデータレシーバーが受信バッファースペースの合計（INIT / INIT ACKで指定されている）から離れたバッファースペースの量を表します. a_rwnd、Cumulative TSN Ack、およびGap Ack Blocksを使用して、データ送信者はピアの受信バッファースペースの表現を開発できます. 

SACKを処理するときにデータ送信者が考慮しなければならない問題の1つは、SACKが順不同で受信される可能性があることです. つまり、データ受信者が送信したSACKは、以前のSACKを通過して、データ送信者が最初に受信できます. からSACKを受信した場合

データセンダーは、ピアの受信バッファースペースの誤ったビューを作成する可能性があります.  

異常なSACKの検出に使用できる明示的な識別子はないため、データ送信者はヒューリスティックを使用してSACKが新しいかどうかを判断する必要があります.  

エンドポイントは、受信したSACKのa_rwnd値、累積TSN Ack、およびギャップAckブロックを使用して、次のルールを使用してrwndを計算する必要があります.  

A）アソシエーションの確立時に、エンドポイントは、INITまたはINIT ACKで指定されたピアのアドバタイズされたレシーバウィンドウクレジット（a_rwnd）へのrwndを初期化します.  

B）DATAチャンクがピアに送信（または再送信）されるたびに、エンドポイントはそのピアのrwndからチャンクのデータサイズを減算します.  

C）T3-rtxタイマーの有効期限（セクション6.3.3）または高速再送信（セクション7.2.4）のいずれかを使用して、DATAチャンクが再送信用にマークされるたびに、それらのチャンクのデータサイズをrwndに追加します.  

注：実装が各DATAチャンクでタイマーを維持している場合、タイマーが期限切れになったDATAチャンクのみが再送信用にマークされます.  

D）SACKが到着するたびに、エンドポイントは次を実行します.  

i）累積TSN Ackが累積TSN Ackポイントより小さい場合、SACKをドロップします. 累積TSN Ackは単調に増加するため、累積TSN Ackが累積TSN Ackポイントよりも小さいSACKは、SACKが異常であることを示します. 

ii）rwndを、新しく受信したa_rwndから、累積TSN AckおよびGap Ackブロックの処理後にまだ未解決のバイト数を引いた値に設定します.  

iii）ギャップACKブロックを介して以前に確認されたTSNがSACKにない場合（たとえば、データで無効になったデータレシーバー）、おそらく欠落している可能性のある対応するデータを検討します. セクション7.2.4で、DATAチャンクが最初に送信された宛先アドレスに対して再送信タイマーが実行されていない場合、その宛先アドレスに対してT3-rtxが開始されます.  

iv）累積TSN Ackが高速リカバリ出口点（セクション7.2.4）に一致するか、それを超える場合、高速リカバリは終了します.  

6.3. 再送信タイマーの管理

SCTPエンドポイントは、再送信タイマーT3-rtxを使用して、ピアからのフィードバックがない場合にデータ配信を保証します. このタイマーの期間は、RTO（再送信タイムアウト）と呼ばれます. 

エンドポイントのピアがマルチホームの場合、エンドポイントは、ピアエンドポイントの異なる宛先トランスポートアドレスごとに個別のRTOを計算します.  

SCTPでのRTOの計算と管理は、TCPが再送信タイマーを管理する方法に厳密に従います. 現在のRTOを計算するために、エンドポイントは宛先トランスポートアドレスごとに2つの状態変数を維持します. SRTT（スムーズな往復時間）とRTTVAR（往復時間変動）です. 

6.3.1. RTO計算

SRTT、RTTVAR、およびRTOの計算を管理する規則は次のとおりです.  

C1）指定された宛先トランスポートアドレスに送信されたパケットのRTT測定が行われるまで、RTOをプロトコルパラメーター「RTO.Initial」に設定します.  

C2）最初のRTT測定Rが行われたとき、設定 

SRTT <-R、 

RTTVAR <-R / 2、および 

RTO <-SRTT + 4 * RTTVAR.  

C3）新しいRTT測定R 'が行われたら、設定する 

RTTVAR <-（1-RTO.Beta）* RTTVAR + RTO.Beta * | SRTT-R '| 

そして 

SRTT <-（1-RTO.Alpha）* SRTT + RTO.Alpha * R ' 

注：RTTVARの更新で使用されるSRTTの値は、2番目の割り当てを使用してSRTT自体を更新する前の値です.  

計算後、RTO <-SRTT + 4 * RTTVARを更新します. C4）データが飛行中であり、以下のルールC5で許可されている場合、ラウンドトリップごとに新しいRTT測定を行う必要があります. さらに、新しいRTT測定は、指定された宛先トランスポートアドレスのラウンドトリップごとに1回のみ行う必要があります. この推奨事項には2つの理由があります. 1つ目は、より頻繁に測定しても実際には大きなメリットが得られないように見える[ALLMAN99]. 第二に、測定がより頻繁に行われる場合、SRTTとRTTVARがほぼ同じレートで変化に調整されるように、上記のルールC3のRTO.AlphaとRTO.Betaの値を調整する必要があります（往復回数）ラウンドトリップごとに1つの測定のみを行い、ルールC3で指定されているようにRTO.AlphaおよびRTO.Betaを使用する場合のように、新しい値を反映するためにそれらを取得します しかしながら、

C5）カーンのアルゴリズム：再送されたパケットを使用してRTT測定を行ってはならない（したがって、応答がチャンクの最初のインスタンスに対するものか、後のインスタンスに対するものかはあいまいである） 

実装ノート：RTT測定は、rが最初に送信されてからr以下のTSNを持つチャンクが再送信されない場合にのみ、TSN rを持つチャンクを使用して行われるべきです.  

C6）RTOが計算されるたびに、RTO.Min秒未満の場合、RTO.Min秒に切り上げられます. この規則の理由は、高い最小値を持たないRTOが不必要なタイムアウトの影響を受けやすいことです[ALLMAN99]. 

C7）RTO.max秒以上であれば、RTOに最大値を設定できます.  

RTT測定値とさまざまな状態変数の計算に使用されるクロック粒度Gには、次のもの以外の要件はありません.  

G1）RTTVARが計算されるたびに、RTTVAR = 0の場合、RTTVAR <-Gを調整します.  

経験[ALLMAN99]は、より細かいクロック粒度（<= 100ミリ秒）が、より粗い粒度よりも多少優れていることを示しています.  













6.3.2. 再送信タイマールール

再送信タイマーを管理するためのルールは次のとおりです.  

R1）DATAチャンクが（再送信を含む）任意のアドレスに送信されるたびに、そのアドレスのT3-rtxタイマーが実行されていない場合、そのアドレスのRTOの後に期限切れになるように実行を開始します. ここで使用されるRTOは、以下のルールE2で説明されているように、対応する宛先アドレスでの以前のT3-rtxタイマーの期限切れによる倍増後に取得されたものです. 

R2）アドレスに送信されたすべての未処理データが確認されるたびに、そのアドレスのT3-rtxタイマーをオフにします.  

R3）そのアドレスの最も早い未解決のTSNでDATAチャンクを確認するSACKを受信するたびに、現在のRTOでそのアドレスのT3-rtxタイマーを再起動します（そのアドレスに未解決のデータがまだある場合）.  

R4）GACK Ackブロックを介して以前に確認されたTSNがないSACKを受信するたびに、DATAチャンクが最初に送信された宛先アドレスに対してT3-rtxを開始します（まだ実行されていない場合）.  

次の例は、さまざまなタイマールールの使用方法を示しています（受信者が遅延確認応答を使用すると仮定）.  

エンドポイントAエンドポイントZ {アプリが送信を開始}データ[TSN = 7、Strm = 0、Seq = 3] ------------>（ack delay）（Start T3-rtx timer）{App 1つのメッセージを送信します. strm 1}（データを含むバンドルack）DATA [TSN = 8、Strm = 0、Seq = 4] ---- \ /-SACK [TSN Ack = 7、Block = 0] \ / DATA [TSN = 6、 Strm = 1、Seq = 2] \ /（T3-rtxタイマーを開始）\ / \（T3-rtxタイマーを再開）<------ / \->（ack遅延）（ack遅延）{ackを送信} SACK [TSN Ack = 6、Block = 0] -------------->（T3-rtxタイマーをキャンセル）..（ackを送信）（T3-rtxタイマーをキャンセル）<- ------------ SACK [TSN Ack = 8、Block = 0]

図8：タイマールールの例 

6.3.3. T3-rtx有効期限の処理

宛先アドレスの再送信タイマーT3-rtxが期限切れになるたびに、次を実行します.  

E1）タイマーが期限切れになる宛先アドレスについては、セクション7.2.3で定義されたルールを使用してssthreshを調整し、cwnd <-MTUを設定します.  

E2）タイマーの期限が切れる宛先アドレスについて、RTO <-RTO * 2（「タイマーをオフに戻す」）を設定します. 上記の規則C7で説明した最大値（RTO.max）を使用して、この2倍演算の上限を指定できます. 

E3）宛先トランスポートアドレスに対応するパスのMTU制約に従い、T3-rtxが期限切れになったアドレスの最も早い（つまり、最も低いTSN）未処理のデータチャンクの数を決定します. 再送信が送信されています（これは、タイマーが期限切れになるアドレスとは異なる場合があります. セクション6.4を参照してください）. この値をKと呼びます. これらのK個のDATAチャンクを1つのパケットにまとめて宛先エンドポイントに再送信します. 

E4）上記のルールR1がそうすることを示している場合、再送信が送信される宛先アドレスで再送信タイマーT3-rtxを開始します. T3-rtxを開始するために使用されるRTOは、再送信の送信先アドレスのRTOである必要があります. これは、受信者がマルチホームの場合、タイマーが期限切れになった宛先アドレスとは異なる場合があります（セクションを参照） 6.4以下）. 

再送信後、新しいRTT測定値が取得されると（ルールC5に従って、またはHEARTBEATから行われた測定のために新しいデータが送信および確認された場合にのみ発生する可能性があります. セクション8.3を参照）、ルールC3の計算が実行されます.  RTOの計算を含みます. これにより、RTOが2倍になった後に「崩壊」する可能性があります（ルールE2）.  

注：T3-rtxタイマーが期限切れになったが1つのMTU（上記のルールE3）に適合しなかったアドレスに送信されたDATAチャンクは、再送信用にマークされ、cwndが許可するとすぐに送信されます（通常、SACKが到着したとき） ）.  

再送信タイマーを管理するための最後のルールは、フェイルオーバーに関するものです（セクション6.4.1を参照）.  



F1）エンドポイントが現在の宛先トランスポートアドレスから別の宛先トランスポートアドレスに切り替わるたびに、現在の再送信タイマーは実行されたままになります. エンドポイントがDATAチャンクを含むパケットを新しいトランスポートアドレスに送信するとすぐに、ルールR1が指示する場合、データの送信先アドレスのRTO値を使用して、そのトランスポートアドレスでタイマーを開始しますそう. 

6.4. マルチホームSCTPエンドポイント

SCTPエンドポイントは、そのエンドポイントに到達するための宛先アドレスとして使用できるトランスポートアドレスが複数ある場合、マルチホームと見なされます.  

さらに、エンドポイントのULPは、マルチホームピアエンドポイントの複数の宛先アドレスのいずれかをプライマリパスとして選択します（詳細については、セクション5.1.2およびセクション10.1を参照してください）.  

デフォルトでは、SCTPユーザーが使用する宛先トランスポートアドレス（および場合によってはソーストランスポートアドレス）を明示的に指定しない限り、エンドポイントは常にプライマリパスに送信する必要があります.  

エンドポイントは、返信チャンク（SACK、HEARTBEAT ACKなど）を、返信先のデータまたは制御チャンクを受信したのと同じ宛先トランスポートアドレスに送信する必要があります. エンドポイントが応答チャンクとともにDATAチャンクをバンドルしている場合も、このルールに従う必要があります. 

ただし、単一のSACKで異なる送信元アドレスからパケットで受信した複数のDATAチャンクを確認すると、確認されているDATAまたは制御チャンクの受信元の宛先トランスポートアドレスの1つにSACKチャンクが送信される場合があります.  

重複したDATAチャンクの受信者がマルチホームエンドポイントにSACKを送信する場合、宛先アドレスを変更し、DATAチャンクのソースアドレスを使用しないことが有益な場合があります. その理由は、マルチホームエンドポイントから重複を受信すると、SACKのリターンパス（DATAチャンクの送信元アドレスで指定されている）が壊れていることを示す場合があるためです. 

さらに、ピアがマルチホームの場合、エンドポイントは、DATAチャンクが送信された最後の宛先アドレスとは異なるアクティブな宛先トランスポートアドレスにタイムアウトしたチャンクを再送信しようとする必要があります.  

再送信は、未処理の合計データ数には影響しません. ただし、DATAチャンクが別の宛先アドレスに再送信される場合、新しい宛先アドレスの未処理データカウントと、データチャンクが最後に送信された古い宛先アドレスの両方が適宜調整されます. 

6.4.1. 非アクティブな宛先アドレスからのフェイルオーバー

マルチホームSCTPエンドポイントのトランスポートアドレスの一部は、特定のエラー状態（セクション8.2を参照）の発生またはSCTPユーザーからの調整により、非アクティブになる場合があります.  

送信するアウトバウンドデータがあり、プライマリパスが（障害などにより）非アクティブになった場合、またはSCTPユーザーがULPにエラーを報告する前に非アクティブな宛先トランスポートアドレスにデータを送信することを明示的に要求する場合、SCTPエンドポイントは代替のアクティブな宛先トランスポートアドレス（存在する場合）にデータを送信してください.  

タイムアウトしたデータを再送信するときに、エンドポイントがマルチホームの場合、再送信選択ポリシーで各送信元と宛先のアドレスのペアを考慮する必要があります. タイムアウトしたデータを再送信する場合、エンドポイントは、パケットが送信された元のソースと宛先のペアから最も発散したソースと宛先のペアを選択しようとする必要があります. 

注：最も発散するソースとデスティネーションのペアを選択するためのルールは実装の決定であり、このドキュメントでは指定されていません.  

6.5. ストリーム識別子とストリームシーケンス番号

すべてのDATAチャンクには、有効なストリーム識別子を含める必要があります. エンドポイントが無効なストリーム識別子を持つDATAチャンクを受信した場合、通常の手順に従ってDATAチャンクの受信を確認し、原因が「無効なストリーム識別子」に設定されたERRORチャンクをすぐに送信します（セクション3.3.10を参照）.  DATAチャンクを破棄します. ERRORがSACKに続く限り、エンドポイントはSACKと同じパケットにERRORチャンクをバンドルできます. 

すべてのストリームのストリームシーケンス番号は、関連付けが確立されると0から開始する必要があります. また、ストリームシーケンス番号が値65535に達すると、次のストリームシーケンス番号を0に設定する必要があります. 

6.6. 順序付きおよび順序なし配信

ストリーム内で、エンドポイントは、ストリームシーケンス番号の順序に従って、0に設定されたUフラグで受信したDATAチャンクを上位層に配信する必要があります. DATAチャンクが次の順序で到着しない場合

ストリームシーケンス番号、エンドポイントは、順序変更されるまで、受信したDATAチャンクを配信からULPに保持する必要があります.  

ただし、SCTPエンドポイントは、DATAチャンクのUフラグを1に設定することにより、ストリーム内で送信される特定のDATAチャンクに順序付き配信が不要であることを示すことができます.  

エンドポイントは、Uフラグが1に設定されたDATAチャンクを受信すると、順序付けメカニズムをバイパスし、すぐにデータを上位層に配信する必要があります（データ送信者によってユーザーデータが断片化されている場合は再アセンブリ後）.  

これにより、特定のストリームで「帯域外」データを効率的に送信できます. また、そのストリームを介して送信されるすべてのDATAチャンクでUフラグを1に設定するだけで、ストリームを「順序付けられていない」ストリームとして使用できます. 

実装に関する注：順序付けされていないDATAチャンクを送信する場合、実装は、可能であれば、アウトバウンド送信キューの先頭にあるアウトバウンドパケットにDATAチャンクを配置することを選択できます.  

Uフラグが1に設定されたDATAチャンクの「ストリームシーケンス番号」フィールドには意味がありません. 送信者は任意の値を入力できますが、受信者はフィールドを無視しなければなりません. 

注：順序付けられたデータと順序付けられていないデータを送信する場合、エンドポイントは、Uフラグが1に設定されたDATAチャンクを送信するときにストリームシーケンス番号をインクリメントしません.  

6.7. 受信したデータTSNのギャップを報告する

新しいDATAチャンクを受信すると、エンドポイントは受信したTSNの連続性を検査します. エンドポイントが受信したデータチャンクシーケンスのギャップを検出した場合、すぐにギャップACKブロックを含むSACKを送信する必要があります. データ受信者は、ギャップを埋めない各SCTPパケットを受信した後、SACKの送信を続けます. 

エンドポイントは、受信したSACKのGap Ack Blockに基づいて、欠落しているDATAチャンクを計算し、それらを再送信するかどうかを決定できます（詳細についてはセクション6.2.1を参照）.  

1つのSACKで複数のギャップを報告できます（セクション3.3.4を参照）.  

ピアがマルチホームの場合、SCTPエンドポイントは常に、最後のDATAチャンクが受信されたのと同じ宛先アドレスにSACKを送信しようとする必要があります.  

SACKを受信すると、エンドポイントは、送信キューからSACKの累積TSN Ackによって確認されたすべてのDATAチャンクを削除する必要があります. エンドポイントは、SACKによって「欠落」として報告されたGap Ackブロックに含まれていないTSNを持つすべてのDATAチャンクも処理する必要があります. 再送信の決定を行うために、データ送信者は各未処理のデータチャンクの「欠落」レポートの数を記録する必要があります. 詳細については、セクション7.2.4を参照してください. 

次の例は、SACKを使用してギャップを報告する方法を示しています.  

エンドポイントAエンドポイントZ {アプリは3つのメッセージを送信します. strm 0} DATA [TSN = 6、Strm = 0、Seq = 2] ---------- ----->（ack delay）（Start T3-rtx timer）

データ[TSN = 7、Strm = 0、Seq = 3] --------> X（lost） 

DATA [TSN = 8、Strm = 0、Seq = 4] --------------->（ギャップが検出され、すぐにackを送信）/ ----- SACK [TSN Ack = 6 、Block = 1、/ Start = 2、End = 2] <----- /（6をout-queueから削除し、7を "1"欠落レポートとしてマーク） 

図9：SACKを使用してギャップを報告する 

単一のSACKチャンク内で報告できるGap Ackブロックの最大数は、現在のパスMTUによって制限されます. 単一のSACKがMTU制限のために報告する必要があるすべてのGap Ackブロックをカバーできない場合、エンドポイントはMACKによって設定されたサイズ制限内で、最低から最高のTSNからGap Ackブロックを報告する1つのSACKのみを送信する必要があります. 残りの最大のTSN番号を未確認のままにします. 

6.8. CRC32cチェックサム計算

SCTPパケットを送信する場合、エンドポイントは、以下で説明するように、パケットで計算されたCRC32cチェックサム値を含めることにより、伝送のデータ整合性を強化する必要があります.  

パケットが構築された後（SCTP共通ヘッダーと1つ以上の制御またはDATAチャンクを含む）、送信者は 

1）SCTP共通ヘッダーに適切な検証タグを入力し、チェックサムフィールドを「0」に初期化します.  

2）SCTP共通ヘッダーとすべてのチャンクを含むパケット全体のCRC32cチェックサムを計算します（CRC32cアルゴリズムの詳細については、付録Bを参照してください）. 3）結果の値を共通ヘッダーのチェックサムフィールドに入れ、残りのビットは変更しないままにします. 

SCTPパケットを受信すると、受信者は最初に次のようにCRC32cチェックサムをチェックする必要があります.  

1）受信したCRC32cチェックサム値を別に保存します.  

2）受信したSCTPパケットのチェックサムフィールドの32ビットをすべて「0」に置き換え、受信したパケット全体のCRC32cチェックサム値を計算します.  

3）計算されたCRC32cチェックサムが受信したCRC32cチェックサムと同じであることを確認します. そうでない場合、受信者はパケットを無効なSCTPパケットとして扱わなければなりません. 

無効なSCTPパケットを処理するデフォルトの手順は、それらを静かに破棄することです.  

ハードウェアの実装は、ソフトウェアで検証可能な方法で実行する必要があります.  

6.9. 断片化と再構築

エンドポイントは、DATAチャンクを送信するときにフラグメンテーションをサポートする場合がありますが、DATAチャンクを受信するときに再アセンブリをサポートする必要があります. エンドポイントがフラグメンテーションをサポートしている場合、送信されるユーザーメッセージのサイズによってアウトバウンドSCTPパケットサイズが現在のMTUを超える場合、エンドポイントはユーザーメッセージをフラグメント化する必要があります. 実装がアウトバウンドユーザーメッセージの断片化をサポートしない場合、エンドポイントはその上位層にエラーを返さなければならず、ユーザーメッセージを送信しようとはしません. 

注：フラグメンテーションをサポートする実装が、その上位層でフラグメンテーションをオフにするメカニズムを利用できるようにする場合、そうするかもしれません. ただし、そうすることで、フラグメンテーションをサポートしない実装と同じように反応する必要があります. つまり、現在のパスMTU（P-MTU）を超える送信を拒否しなければなりません. 

実装注：このエラーの場合、セクション10.1で説明した送信プリミティブは、上位層にエラーを返す必要があります.  

ピアがマルチホームの場合、エンドポイントはアソシエーションパスMTU以下のサイズを選択する必要があります. アソシエーションパスMTUは、すべての宛先アドレスの最小パスMTUです. 





注：メッセージが断片化されると、再断片化することはできません. 代わりに、PMTUが削減されている場合は、IPフラグメンテーションを使用する必要があります. PMTUディスカバリーの詳細については、セクション7.3を参照してください. 

いつフラグメント化するかを決定するとき、SCTP実装はSCTPパケットヘッダーとDATAチャンクヘッダーを考慮しなければなりません. 実装では、SACKチャンクをDATAチャンクとバンドルする場合、SACKチャンクに必要なスペースも考慮する必要があります. 

フラグメンテーションは次の手順を実行します.  

1）データ送信者は、ユーザーメッセージを一連のDATAチャンクに分割して、各チャンクとSCTPオーバーヘッドがアソシエーションパスMTU以下のIPデータグラムに収まるようにしなければなりません（MUST）.  

2）送信機は、一連のデータチャンクのそれぞれに個別のTSNを順番に割り当てなければなりません. 送信機は、同じSSNを各DATAチャンクに割り当てます. ユーザーが、ユーザーメッセージが順不同配信を使用して配信されることを示している場合、ユーザーメッセージの各DATAチャンクのUフラグを1に設定する必要があります. 

3）送信機はまた、シリーズの最初のDATAチャンクのB / Eビットを「10」、シリーズの最後のDATAチャンクのB / Eビットを「01」に、B / Eビットをシリーズの他のすべてのDATAチャンクを「00」にします.  

エンドポイントは、受信した各DATAチャンクのB / Eビットを調べることにより、断片化されたDATAチャンクを認識し、再構成のために断片化されたDATAチャンクをキューに入れなければなりません. ユーザーメッセージが再構成されると、SCTPは、再構成されたユーザーメッセージを特定のストリームに渡して、可能な並べ替えと最終ディスパッチを行います. 

注：データレシーバーがメッセージの再構成を完了するためにさらにフラグメントを待機している間にバッファスペースが不足した場合、受信メッセージの一部を部分配信API（セクション10を参照）を介してディスパッチし、受信バッファーの一部を解放する必要がありますメッセージの残りを受信できるようにスペース.  

6.10. 同梱

エンドポイントは、1つの発信SCTPパケットに複数のチャンクを含めるだけで、チャンクをバンドルします. 結果のIPデータグラムの合計サイズ、

SCTPパケットとIPヘッダーを含め、現在のパスMTU以下でなければなりません.  

ピアエンドポイントがマルチホームの場合、送信エンドポイントは、現在のプライマリパスの最新のMTU以下のサイズを選択します.  

制御チャンクをDATAチャンクとバンドルする場合、エンドポイントは、アウトバウンドSCTPパケットに最初に制御チャンクを配置する必要があります. 送信機は、TSNの昇順でSCTPパケット内のDATAチャンクを送信しなければなりません. 

注：制御チャンクはパケットの最初に配置する必要があり、DATAチャンクはSHUTDOWNまたはSHUTDOWN ACKチャンクの前に送信する必要があるため、DATAチャンクをSHUTDOWNまたはSHUTDOWN ACKチャンクにバンドルすることはできません.  

部分チャンクをSCTPパケットに配置してはなりません（MUST NOT）. 部分チャンクは、SCTPパケットに完全には含まれないチャンクです. つまり、SCTPパケットは短すぎて、チャンクの長さで示されるチャンクのすべてのバイトを含めることができません. 

エンドポイントは、受信したチャンクをパケット内の順序で処理する必要があります. 受信側は、チャンク長フィールドを使用して、すべてのチャンクが4バイト境界で終了するという事実を考慮して、チャンクの終わりと次のチャンクの始まりを決定します. 受信者が部分的なチャンクを検出した場合、チャンクをドロップしなければなりません. 

エンドポイントは、INIT、INIT ACK、またはSHUTDOWN COMPLETEを他のチャンクとバンドルしてはいけません.  

7.輻輳制御 

輻輳制御は、SCTPの基本機能の1つです. 一部のアプリケーションでは、タイムクリティカルなデータの迅速な配信を確保するために適切なリソースがSCTPトラフィックに割り当てられる可能性があります. したがって、通常の運用中に、伝送が深刻な輻輳状態に遭遇する可能性は低いようです. ただし、SCTPは、ネットワークの部分的な障害や予期しないトラフィックの急増により発生する可能性のある悪条件で動作する必要があります. そのような状況では、データをできるだけ早く配信するために、SCTPは正しい輻輳制御手順に従って輻輳から迅速に回復する必要があります. ネットワーク輻輳がない場合、これらの予防的な輻輳制御アルゴリズムは、プロトコルのパフォーマンスに影響を与えないはずです. 

実装に関する注：特定のパフォーマンス要件が満たされる限り、実装は常に、以下で定義されているものよりも保守的な輻輳制御アルゴリズムを採用できます.  



SCTPで使用される輻輳制御アルゴリズムは、[RFC2581]に基づいています. このセクションでは、[RFC2581]で定義されたアルゴリズムがSCTPでの使用にどのように適合されるかについて説明します. 最初にTCPとSCTPのプロトコル設計の違いをリストし、次にSCTPの輻輳制御スキームについて説明します. 説明では、必要に応じてTCP輻輳制御と同じ用語を使用します. 

SCTP輻輳制御は、個々のストリームではなく、関連付け全体に常に適用されます.  

7.1. TCP輻輳制御とのSCTPの違い

SCTP SACKのGap Ackブロックは、TCP SACKと同じ意味を持ちます. TCPは、SACKで伝送される情報を助言情報と見なします. SCTPは、SACKチャンクのGap Ackブロックで伝達される情報を助言と見なします. SCTPでは、SACKによって確認されたDATAチャンク（受信端に順不同で到着したDATAを含む）は、累積TSN確認ポイントがDATAチャンクのTSNを渡すまで完全に配信されたと見なされません（つまり、DATAチャンクはSACKの累積TSN Ackフィールドによって確認されました）. したがって、cwndの値は、（非SACK TCPの場合のように）確認済みの最大シーケンス番号と輻輳ウィンドウ内で送信できる最新のDATAチャンクの上限ではなく、未処理データの量を制御します. SCTP SACKは、非SACK TCPとは異なる高速再送信および高速回復の実装をもたらします. 例として、[FALL96]を参照してください. 

ただし、SCTPとTCPの最大の違いはマルチホーミングです. SCTPは、それぞれが複数のトランスポートアドレスで到達可能な2つのエンドポイント間に堅牢な通信アソシエーションを確立するように設計されています. 潜在的に異なるアドレスは、2つのエンドポイント間で異なるデータパスにつながる可能性があります. したがって、理想的には、パスごとに輻輳制御パラメータの個別のセットが必要になる場合があります. ここでのマルチホーム受信機の輻輳制御の扱いはSCTPで新しく、将来的に改良が必要になる場合があります. 現在のアルゴリズムでは、次のことを想定しています. 

o送信者は通常、上位層から別の方法で指示されるまで同じ宛先アドレスを使用します. ただし、アドレスが非アクティブとマークされた場合、SCTPは代替宛先に変更される場合があります（セクション8.2を参照）. また、SCTPは元の送信とは異なるトランスポートアドレスに再送信する場合があります. 

o送信者は、送信可能な宛先アドレスごとに、個別の輻輳制御パラメーターセットを保持します（各送信元と宛先のペアではなく、各宛先に対して）. パラメーター

アドレスが十分な期間使用されない場合、減衰するはずです.  

o宛先アドレスごとに、エンドポイントはそのアドレスへの最初の送信時にスロースタートを行います.  

注：TCPは、単一のTCPセッション内での上位層プロトコルへのデータの順序どおりの配信を保証します. これは、TCPが受信したシーケンス番号にギャップを検出すると、ギャップが埋められるまで待機してから、欠落データのシーケンス番号よりも大きいシーケンス番号で受信したデータを配信することを意味します. 一方、SCTPは、ストリームシーケンス番号が特定のストリームに対して連続している場合（つまり、欠落しているDATAチャンクが別のストリーム用である場合）、またはTSNにギャップがある場合でも、上位層プロトコルにデータを配信できます順不同の配達が示されます. これはcwndには影響しませんが、rwndの計算に影響する場合があります. 

7.2. SCTPスロースタートおよび輻輳回避

ネットワークに注入されるデータの量を制御するために、スロースタートおよび輻輳回避アルゴリズムをエンドポイントで使用する必要があります. SCTPの輻輳制御は、個々のストリームではなく、アソシエーションに関して使用されます. 状況によっては、SCTP送信者がアルゴリズムで許可されているよりも保守的であることが有益な場合があります. ただし、SCTP送信者は、次のアルゴリズムが許可するよりも積極的であってはなりません. 

TCPと同様に、SCTPエンドポイントは次の3つの制御変数を使用して、伝送速度を調整します.  

o受信側がアドバタイズしたウィンドウサイズ（バイト単位のrwnd）. これは、受信パケットの利用可能なバッファスペースに基づいて受信側によって設定されます.  

注：この変数は、関連付け全体に保持されます.  

o輻輳制御ウィンドウ（cwnd、バイト単位）. 観測されたネットワーク状態に基づいて送信者が調整します.  

注：この変数は、宛先アドレスごとに維持されます.  

oスロースタートしきい値（ssthresh、バイト単位）. 送信者がスロースタートと輻輳回避フェーズを区別するために使用します.  

注：この変数は、宛先アドレスごとに維持されます.  

SCTPでは、cwnd調整を容易にするために輻輳回避フェーズで使用される追加の制御変数partial_bytes_ackedも必要です.  

TCPとは異なり、SCTP送信者は、（ピアがマルチホームの場合）ピアの各宛先アドレスに対して、これらの制御変数cwnd、ssthresh、およびpartial_bytes_ackedのセットを保持する必要があります. アソシエーション全体に対して1つのrwndのみが保持されます（ピアがマルチホームであるか、単一のアドレスを持っているかどうかは関係ありません）. 

7.2.1. スロースタート

未知の条件でネットワークへのデータ送信を開始するか、十分に長いアイドル期間の後、SCTPがネットワークをプローブして使用可能な容量を決定する必要があります. スロースタートアルゴリズムは、転送の開始時、または再送信タイマーによって検出された損失の修復後に、この目的で使用されます. 

oデータ送信前または十分に長いアイドル期間後の初期cwndは、min（4 * MTU、max（2 * MTU、4380バイト））に設定する必要があります.  

o再送信タイムアウト後の初期cwndは、1 * MTU以下でなければなりません.  

o ssthreshの初期値は、任意に高くすることができます（たとえば、実装は、受信者がアドバタイズしたウィンドウのサイズを使用できます）.  

o cwndがゼロより大きい場合は常に、エンドポイントはそのトランスポートアドレスでcwndバイトのデータを未処理にすることができます.  

o cwndがssthresh以下の場合、SCTPエンドポイントはスロースタートアルゴリズムを使用して、現在の輻輳ウィンドウが完全に利用されている場合にのみcwndを増加しなければならず、着信SACKは累積TSN Ackポイントを進め、データ送信者は高速リカバリではありません. これらの3つの条件が満たされた場合のみ、cwndを増やすことができます. それ以外の場合、cwndを増やすことはできません. これらの条件が満たされている場合、cwndは、1）確認済みの以前に未処理のDATAチャンクの合計サイズ、2）宛先のパスMTUのいずれか小さい方まで増加する必要があります. この上限は、[SAVAGE99]で概説されているACK-Splitting攻撃から保護します. 

ピアエンドポイントがマルチホームである場合、エンドポイントが累積TSN確認ポイントを進めるSACKを受信した場合、確認済みデータを送信した宛先アドレスに割り当てられたcwnd（またはcwnds）を更新する必要があります. ただし、受信したSACKが累積TSN Ackポイントを進めない場合、エンドポイントは宛先アドレスのcwndを調整してはなりません. 

エンドポイントのcwndは累積TSN Ackポイントに結び付けられていないため、重複SACKが着信すると、累積TSN Ackポイントを進めなくても、エンドポイントはそれらを使用して新しいデータをクロックアウトできます. つまり、SACKによって新たに確認されたデータにより、現在飛行中のデータ量がcwnd未満に減少するため、現在の変更されていないcwndの値によって新しいデータを送信できるようになります. 一方、cwndの増加は、上記のように累積TSN確認ポイントの進歩に結び付けられなければなりません. そうしないと、重複したSACKが新しいデータをクロックアウトするだけでなく、輻輳の可能性があるときに、ネットワークを出たばかりのデータよりも多くの新しいデータをクロックアウトします. 

oエンドポイントが特定のトランスポートアドレスでデータを送信しない場合、トランスポートアドレスのcwndはRTOごとにmax（cwnd / 2、4 * MTU）に調整する必要があります.  

7.2.2. 輻輳回避

cwndがssthreshより大きい場合、対応するトランスポートアドレスに対してcwnd以上のバイトのデータが送信者にある場合、RTTごとにcwndを1 * MTUずつ増やす必要があります.  

実際には、実装は次の方法でこの目標を達成できます.  

o partial_bytes_ackedは0に初期化されます.  

o cwndがssthreshよりも大きい場合は、累積TSN Ackポイントを進めるSACKが到着するたびに、新しい累積TSN AckおよびGap Ackブロックによって確認されたチャンクを含む、そのSACKで確認されたすべての新しいチャンクの合計バイト数でpartial_bytes_ackedを増やします.  

o partial_bytes_ackedがcwnd以上で、SACKの到着前に送信者がcwnd以上のバイトのデータを未処理にした場合（つまり、SACKの到着前に、flightizeizeはcwnd以上でした）、cwndをMTUだけ増やします、およびpartial_bytes_ackedを（partial_bytes_acked-cwnd）にリセットします.  

oスロースタートと同じ、送信者が特定のトランスポートアドレスでDATAを送信しない場合、トランスポートアドレスのcwndはRTOごとにmax（cwnd / 2、4 * MTU）に調整する必要があります.  



o送信者によって送信されたすべてのデータが受信者によって確認されると、partial_bytes_ackedは0に初期化されます.  

7.2.3. 輻輳制御

SACKからのパケット損失を検出すると（セクション7.2.4を参照）、エンドポイントは以下を実行する必要があります.  

ssthresh = max（cwnd / 2、4 * MTU）cwnd = ssthresh partial_bytes_acked = 0 

基本的に、パケット損失によりcwndは半分になります.  

アドレスでT3-rtxタイマーが期限切れになると、SCTPは次の方法でスロースタートを実行する必要があります.  

ssthresh = max（cwnd / 2、4 * MTU）cwnd = 1 * MTU 

また、エンドポイントがそのアドレスへのデータ配信が成功したことに対する確認応答を受信するまで、そのアドレスに対して複数のSCTPパケットが送信されないようにします.  

7.2.4. ギャップレポートの高速再送信

データの損失がない場合、エンドポイントは遅延確認応答を実行します. ただし、エンドポイントは、到着するTSNシーケンスに穴があることに気づくたびに、穴がいっぱいになるまでデータを運ぶパケットが到着するたびにSACKの返信を開始する必要があります. 

エンドポイントは、一部のTSNが欠落していることを示すSACKを受信するたびに、同じTSNでさらに2つのミス表示（後続のSACKを介して合計3つの欠落レポートを介して）を待ってから、高速再送信に関するアクションを実行する必要があります.  

ミス表示は、HTNA（Highest TSN Newly Acknowledged）アルゴリズムに従う必要があります（SHOULD）. 着信SACKごとに、ミス通知は、SACKで新たに確認された最高のTSNの前にTSNが欠落している場合にのみ増分されます. 新しく確認されたDATAチャンクは、SACKで以前に確認されなかったものです. エンドポイントがFast Recoveryにあり、累積TSN確認ポイントを進めるSACKが到着した場合、SACKで欠落していると報告されたすべてのTSNのミス表示が増加します. 

TSNの3番目の連続ミス表示を受信すると、データ送信者は次のことを行います. 1）再送信のための3つのミス表示でDATAチャンクをマークします.  

2）Fast Recoveryでない場合、セクション7.2.3で説明されている式に従って、欠落したDATAチャンクが最後に送信された宛先アドレスのssthreshとcwndを調整します.  

3）パケットの送信先の宛先トランスポートアドレスのパスMTUの制約に従って、再送信用にマークされた最も早い（つまり、最も低いTSN）DATAチャンクが1つのパケットに収まる数を決定します. この値をKと呼びます. これらのK個のDATAチャンクを単一のパケットで再送信します. 高速再送信が実行されている場合、送信者はcwndの値を無視する必要があり（SHOULD）、この単一パケットの再送信を遅らせるべきではありません（SHOULD NOT）. 

4）最後のSACKがそのアドレスに送信された最も低い未解決のTSN番号を確認した場合、またはエンドポイントがそのアドレスに送信された最初の未解決のデータチャンクを再送信する場合にのみ、T3-rtxタイマーを再起動します.  

5）DATAチャンクを高速再送信としてマークするため、後続の高速再送信の対象外となります. 他のK個のTSNを伝送する送信データグラムに適合しなかったFast-Retransmitアルゴリズムにより再送信用にマークされたTSNは、後続のFast Retransmitの対象外としてマークされます. ただし、再送信用にマークされているため、cwndが許可するとすぐに再送信されます. 

6）高速リカバリでない場合は、高速リカバリを入力し、未処理の最高TSNを高速リカバリ出口ポイントとしてマークします. SACKがこの出口点までのすべてのTSNを確認すると、高速回復は終了します. 高速回復中、ssthreshとcwndは、後続の高速回復イベントのために宛先に対して変更すべきではありません（つまり、後続の高速再送信のためにcwndをさらに減らすべきではありません）. 

注：上記の調整の前に、受信したSACKが新しいDATAチャンクを確認し、累積TSN Ackポイントを進める場合、セクション7.2.1およびセクション7.2.2で定義されたcwnd調整ルールを最初に適用する必要があります.  

上記の簡単な実装では、SACKによって報告される各TSNホールのカウンターを保持します. カウンタは、TSNホールを報告する連続したSACKごとに増分します. 3に到達し、高速再送信手順を開始すると、カウンターは0にリセットされます. 



SCTPのcwndは未処理のTSNの数を間接的に制限するため、輻輳制御ウィンドウサイズを調整することなく、TCP高速リカバリの効果が自動的に達成されます.  

7.3. パスMTUディスカバリー

[RFC4821]、[RFC1981]、および[RFC1191]は「Packetization Layer Path MTU Discovery」を指定します. これにより、エンドポイントは特定のインターネットパスに沿った最大伝送ユニット（MTU）の推定値を維持し、 MTU. パスMTU（PMTU）の変更をプローブするときどきの試行を除きます. [RFC4821]は、MTU発見メカニズムと、現在のエンドツーエンドMTU設定を決定し、この値の変化を検出するための戦略について十分に議論しています. 

エンドポイントはこれらの手法を適用する必要があり（SHOULD）、宛先アドレスごとに適用する必要があります（SHOULD）.  

パスMTUディスカバリに関して、SCTP固有の重要なポイントが2つあります.  

1）SCTPアソシエーションは複数のアドレスにまたがることができます. エンドポイントは、ピアの各宛先アドレスに対して個別のMTU推定値を維持する必要があります. 

2）送信者は、ピアのすべての宛先アドレスについて発見された最小のPMTUになるアソシエーションPMTUを追跡する必要があります. メッセージを複数の部分にフラグメント化する場合、この関連付けPMTUを使用して各フラグメントのサイズを計算する必要があります. これにより、IPフラグメンテーションが発生することなく、再送信を代替アドレスにシームレスに送信できます. 

8.障害管理 

8.1. エンドポイント障害検出

エンドポイントは、未確認のHEARTBEATチャンクを含む、ピアへの連続した再送信の総数（カウンターがマルチホームの場合、ピアのすべての宛先トランスポートアドレスへの再送信を含む）のカウンターを保持するものとします. このカウンタの値がプロトコルパラメータ「Association.Max.Retrans」で示された制限を超える場合、エンドポイントはピアエンドポイントが到達不能であると見なし、それ以上のデータの送信を停止する必要があります（したがって、アソシエーションはCLOSED状態になります）. さらに、エンドポイントは障害を上位層に報告し、オプションで、アウトバウンドキューに残っているすべての未処理のユーザーデータを報告する場合があります. ピアエンドポイントが到達不能になると、関連付けは自動的に閉じられます. 

8.2. パス障害検出

ピアエンドポイントがマルチホームの場合、エンドポイントは、ピアエンドポイントの宛先トランスポートアドレスごとにエラーカウンターを保持する必要があります.  

T3-rtxタイマーが任意のアドレスで期限切れになるたびに、またはアイドルアドレスに送信されたHEARTBEATがRTO内で確認されない場合、その宛先アドレスのエラーカウンターがインクリメントされます. エラーカウンターの値がその宛先アドレスのプロトコルパラメーター「Path.Max.Retrans」を超えると、エンドポイントは宛先トランスポートアドレスを非アクティブとしてマークし、通知を上位層に送信する必要があります. 

未処理のTSNが確認されるか、そのアドレスに送信されたHEARTBEATがHEARTBEAT ACKで確認されると、エンドポイントは、DATAチャンクが最後に送信された（またはHEARTBEATが送信された）宛先トランスポートアドレスのエラーカウンターをクリアします. ピアエンドポイントがマルチホームであり、そこに送信された最後のチャンクが代替アドレスへの再送信であった場合、送信された最後のチャンクのアドレスに確認応答をクレジットするかどうかに関してあいまいさが存在します. ただし、このあいまいさはSCTPの動作に重大な結果をもたらすとは思われません. このあいまいさが望ましくない場合、送信機は、最後に送信されたチャンクが再送信である場合、エラーカウンターをクリアしないことを選択できます. 

注：SCTPエンドポイントを構成する場合、ユーザーは、「Association.Max.Retrans」の値がリモートエンドポイントのすべての宛先アドレスの「Path.Max.Retrans」の合計よりも大きくなることを避ける必要があります. そうしないと、エンドポイントがピアエンドポイントが到達可能であると見なしている間に、すべての宛先アドレスが非アクティブになる可能性があります. この状態が発生した場合、SCTPが機能する方法は実装固有です. 

プライマリパスが（たとえば、過剰な再送信のために）非アクティブとしてマークされると、送信者は、新しいパケットが存在し、アクティブである場合、新しい宛先アドレスに自動的に送信することができます. プライマリパスが非アクティブとしてマークされているときに複数の代替アドレスがアクティブである場合、1つのトランスポートアドレスのみが選択され、新しい宛先トランスポートアドレスとして使用される必要があります. 







8.3. パスハートビート

デフォルトでは、SCTPエンドポイントは、定期的にHEARTBEATチャンクを宛先トランスポートアドレスに送信することにより、ピアのアイドル宛先トランスポートアドレスの到達可能性を監視する必要があります. HEARTBEATの送信は、ESTABLISHED状態に到達すると開始する場合があり、SHUTDOWNまたはSHUTDOWN-ACKのいずれかを送信した後、中断される場合があります. HEARTBEATの受信者は、COOKIE-ECHOED状態（INIT送信者）またはESTABLISHED状態（INIT受信者）に入った後、SHUTDOWN-SENT状態（SHUTDOWN送信者）またはSHUTDOWNに達するまで、HEARTBEATにHEARTBEAT-ACKで応答する必要があります.  -ACK-SENT状態（シャットダウンレシーバー）. 

宛先トランスポートアドレスは、パスRTTの更新に使用できる新しいチャンク（通常、最初の送信DATA、INIT、COOKIE ECHO、HEARTBEATなどを含む）がなく、現在のハートビート内でHEARTBEATが送信されていない場合、「アイドル」と見なされますそのアドレスの期間. これは、アクティブな宛先アドレスと非アクティブな宛先アドレスの両方に適用されます. 

オプションで、上位層は次の機能を開始できます.  

A）特定の関連付けの特定の宛先トランスポートアドレスでハートビートを無効にします.  

B）HB.intervalを変更し、 

C）特定の関連付けの特定の宛先トランスポートアドレスでハートビートを再度有効にします.  

D）特定のアソシエーションの特定の宛先トランスポートアドレスでオンデマンドハートビートを要求します.  

エンドポイントは、ハートビートがそのアドレスに送信され、1つのRTO内で確認されないたびに、宛先トランスポートアドレスのそれぞれのエラーカウンターをインクリメントする必要があります.  

このカウンターの値がプロトコルパラメーター「Path.Max.Retrans」に達すると、エンドポイントは、対応する宛先アドレスがマークされていない場合は非アクティブとしてマークする必要があり、オプションでこの到達可能性の変更を上位レイヤーに報告することもできます宛先アドレス. この後、エンドポイントはこの宛先アドレスでHEARTBEATを続行する必要がありますが、カウンターの増加を停止する必要があります. 

HEARTBEATチャンクの送信者は、パケットが送信される現在の時刻とパケットの送信先アドレスをチャンクの[ハートビート情報]フィールドに含める必要があります. 実装ノート：使用できるハートビートメカニズムの代替実装は、ハートビートが宛先に送信されるたびにエラーカウンター変数をインクリメントすることです. ハートビートACKが到着するたびに、送信者は、ハートビートが送信された宛先のエラーカウンターをクリアする必要があります. これにより、実際には以前にストロークされたエラー（およびその他のエラーカウント）もクリアされます. 

HEARTBEATの受信者は、受信したHEARTBEATチャンクから変更されずにコピーされた他の受信TLVとともに、ハートビート情報TLVを含むHEARTBEAT ACKで直ちに応答する必要があります.  

HEARTBEAT ACKを受信すると、HEARTBEATの送信者は、HEARTBEATが送信された宛先トランスポートアドレスのエラーカウンターをクリアし、宛先トランスポートアドレスにマークが付いていない場合はアクティブとしてマークする必要があります. エンドポイントは、最新のHEARTBEAT ACKを受信したために非アクティブな宛先アドレスがアクティブとしてマークされると、オプションで上位層に報告する場合があります. HEARTBEAT ACKの受信者は、アソシエーション全体のエラーカウントもクリアする必要があります（セクション8.1で定義）. 

HEARTBEAT ACKの受信者は、HEARTBEAT ACKチャンクで伝送される時間値を使用して、その宛先トランスポートアドレスのRTT測定も実行する必要があります.  

ハートビートが許可されているアイドル宛先アドレスでは、その宛先アドレスのRTOとプロトコルパラメータ「HB.interval」ごとに、RTO値の+/- 50％のジッターでHEARTBEATチャンクを1回送信することをお勧めします. 以前のHEARTBEATに応答がない場合のRTOの指数関数的バックオフ.  

SCTPユーザーには、HB.intervalを変更し、特定の宛先アドレスでハートビートをオンまたはオフにするプリミティブが提供されます. SCTPユーザーが設定したハートビート間隔は、その宛先のRTOに追加されます（指数バックオフを含む）. ハートビートタイマーが期限切れになるたびに、1つのハートビートのみを送信する必要があります（複数の宛先がアイドル状態の場合）. これは、ハートビートの候補となるアイドル宛先を選択する方法に関する実装上の決定です（複数の宛先がアイドル状態の場合）. 

注：ハートビート間隔を調整する場合、副作用が考慮されるべきです（SHOULD）. この値を大きくすると、つまりHEARTBEATの時間が長くなると、失われたABORTメッセージの検出にも時間がかかります. ピアエンドポイントが何らかの理由でアソシエーションをABORTし、ABORTチャンクが失われた場合、ローカルエンドポイントは、DATAチャンクまたはHEARTBEATチャンクを送信することで失われたABORTを検出します（したがって、ピアは別のABORTを送信します）. これは、ハートビートタイマーを調整するときに考慮する必要があります. HEARTBEATが無効になっている場合、関連付けにデータを送信するだけで、ピアから失われたABORTが検出されます. 

8.4. 「Out of the Blue」パケットの処理

SCTPパケットは、正しく形成されている場合（つまり、受信者のCRC32cチェックに合格した場合、セクション6.8を参照）、「out of the blue」（OOTB）パケットと呼ばれますが、受信者はこのパケットが属するアソシエーションを識別できません.  

OOTBパケットの受信者は次のことを行わなければなりません： 

1）OOTBパケットが非ユニキャストアドレスとの間の場合、受信者はパケットを静かに破棄する必要があります（SHOULD）. さもないと、

2）OOTBパケットにABORTチャンクが含まれる場合、受信者はOOTBパケットを静かに破棄し、それ以上のアクションを実行しないでください. さもないと、

3）パケットに検証タグが「0」に設定されたINITチャンクが含まれている場合は、セクション5.1の説明に従って処理します. 何らかの理由でINITを正常に処理できず、応答としてABORTを送信する必要がある場合、ABORTチャンクを含むパケットの検証タグは、受信したINITチャンクの開始タグ、およびABORTのTビットでなければなりませんチャンクは0に設定する必要があります. これは、検証タグが反映されないことを示します. 

4）パケットの最初のチャンクにCOOKIE ECHOが含まれている場合は、セクション5.1の説明に従って処理します. さもないと、

5）パケットにSHUTDOWN ACKチャンクが含まれる場合、受信者はOOTBパケットの送信者にSHUTDOWN COMPLETEで応答する必要があります. SHUTDOWN COMPLETEを送信する場合、OOTBパケットの受信者は、SHUTDOWN ACKで受信した検証タグを送信パケットの検証タグフィールドに入力し、チャンクフラグのTビットを設定して、検証タグが反映されていることを示す必要があります. さもないと、

6）パケットにSHUTDOWN COMPLETEチャンクが含まれる場合、受信者は黙ってパケットを破棄し、それ以上のアクションは行わないでください. さもないと、

7）パケットに「Stale Cookie」エラーまたはCOOKIE A​​CKが含まれている場合、SCTPパケットは静かに破棄されます. さもないと、





8）受信者は、OOTBパケットの送信者にABORTで応答する必要があります. ABORTを送信する場合、OOTBパケットの受信者は、アウトバウンドパケットの検証タグフィールドにOOTBパケットの検証タグフィールドで見つかった値を入力し、チャンクフラグにTビットを設定して、検証タグを示す必要があります反射してる. このABORTを送信した後、OOTBパケットの受信者はOOTBパケットを破棄し、それ以上のアクションを実行しません. 

8.5. 検証タグ

このセクションで定義された検証タグ規則は、INIT、SHUTDOWN COMPLETE、COOKIE ECHO（セクション5.1を参照）、ABORT、またはSHUTDOWN ACKチャンクを含まないSCTPパケットを送受信するときに適用されます. これらのチャンクタイプの1つを含むSCTPパケットを送受信するためのルールについては、セクション8.5.1で個別に説明します. 

SCTPパケットを送信する場合、エンドポイントは、ピアから受信したINITまたはINIT ACKのInitiate Tagパラメータのタグ値を使用して、アウトバウンドパケットのVerification Tagフィールドに入力する必要があります.  

SCTPパケットを受信する場合、エンドポイントは、受信したSCTPパケットの検証タグフィールドの値が自身のタグと一致することを確認する必要があります. 受信した検証タグ値が受信者自身のタグ値と一致しない場合、受信者はパケットを静かに破棄し、以下のセクション8.5.1にリストされている場合を除き、それ以上処理しません. 

8.5.1. 検証タグルールの例外

A）INITを運ぶパケットのルール： 

-送信者は、パケットの検証タグを0に設定する必要があります.  

-エンドポイントが検証タグが0に設定されたSCTPパケットを受信すると、パケットにINITチャンクのみが含まれていることを確認する必要があります. そうでない場合、受信者はパケットを静かに破棄しなければなりません. 

B）ABORTを運ぶパケットのルール： 

-エンドポイントは、アウトバウンドパケットの検証タグフィールドに、宛先エンドポイントのタグ値がわかっている場合は、それを常に入力する必要があります.  

-OOTBパケットへの応答としてABORTが送信される場合、エンドポイントはセクション8.4で説明されている手順に従わなければなりません. -パケットの検証タグフィールドが自身のタグと一致し、Tビットが設定されていない場合、またはピアのタグに設定され、チャンクフラグでTビットが設定されている場合、ABORTの受信者はパケットを受け入れなければなりません. それ以外の場合、受信者はパケットを静かに破棄し、それ以上のアクションを実行しないでください. 

C）シャットダウン完了を運ぶパケットのルール： 

-SHUTDOWN COMPLETEを送信するとき、SHUTDOWN ACKの受信者にTCBがある場合、宛先エンドポイントのタグを使用する必要があり、Tビットを設定してはなりません. TCBが存在しない場合にのみ、送信者はSHUTDOWN ACKからの検証タグを使用し、Tビットを設定する必要があります. 

-SHUTDOWN COMPLETEの受信者は、パケットの検証タグフィールドが自身のタグと一致し、Tビットが設定されていないか、ピアのタグに設定され、Tビットがチャンクフラグに設定されている場合、パケットを受け入れます. それ以外の場合、受信者はパケットを静かに破棄し、それ以上のアクションを実行しないでください. エンドポイントは、SHUTDOWN-ACK-SENT状態でない場合、SHUTDOWN COMPLETEを無視する必要があります. 

D）COOKIE ECHOを運ぶパケットのルール 

-COOKIE ECHOを送信する場合、エンドポイントはINIT ACKで受信した開始タグの値を使用する必要があります.  

-COOKIE ECHOの受信者は、セクション5の手順に従います.  

E）SHUTDOWN ACKを運ぶパケットのルール 

-受信者がCOOKIE-ECHOEDまたはCOOKIE-WAIT状態にある場合、セクション8.4の手順に従う必要があります. つまり、Out Of The Blueパケットとして処理する必要があります. 

9.協会の終了 

エンドポイントは、サービスを終了するときに関連付けを終了する必要があります. アソシエーションは、中止またはシャットダウンのいずれかによって終了できます. アソシエーションのアボートは、アソシエーションの両端で保留中のデータが破棄され、ピアに配信されないという点で、定義上アボートです. アソシエーションのシャットダウンは、いずれかのエンドポイントによるキュー内のすべてのデータがそれぞれのピアに配信されるグレースフルクローズと見なされます. ただし、シャットダウンの場合、SCTPは、片側がデータを送信し続ける一方で、もう一方の端が閉じられるハーフオープン状態（TCPなど）をサポートしません. いずれかのエンドポイントがシャットダウンを実行すると、各ピアの関連付けはユーザーからの新しいデータの受け入れを停止し、SHUTDOWNチャンクの送信または受信時にのみキュー内のデータを配信します. 

9.1. 協会の中止

エンドポイントが既存のアソシエーションを中止することを決定した場合、ピアエンドポイントにABORTチャンクを送信する必要があります. 送信者は、アウトバウンドパケットにピアの検証タグを入力する必要があり、データチャンクをABORTにバンドルしてはなりません. アソシエーションが上位層のリクエストで中止される場合、ユーザー開始中止エラーの原因（セクション3.3.10.12を参照）がABORTチャンクに存在する必要があります. 

エンドポイントは、ABORTチャンクを含む受信パケットに応答してはなりません（セクション8.4も参照）.  

ABORTを受信するエンドポイントは、8.5.1項で説明されている特別な検証タグチェックルールを適用する必要があります.  

検証タグを確認した後、受信エンドポイントはそのレコードから関連付けを削除する必要があり（MUST）、終了を上位層に報告する必要があります. ABORTチャンクにUser-Initiated Abortエラーの原因が存在する場合、Upper Layer Abort Reasonを上位層で使用できるようにする必要があります. 

9.2. アソシエーションのシャットダウン

SHUTDOWNプリミティブ（セクション10.1を参照）を使用すると、関連付け内のエンドポイントの上位層は、関連付けを適切に閉じることができます. これにより、関連付けが終了する前に、シャットダウンイニシエーターのピアからのすべての未処理のDATAチャンクを配信できます. 

上位層からSHUTDOWNプリミティブを受信すると、エンドポイントはSHUTDOWN-PENDING状態に入り、すべての未処理データがピアによって確認されるまでそこに残ります. エンドポイントは、その上位層から新しいデータを受け入れませんが、必要に応じてギャップを埋めるために遠端にデータを再送信します. 

すべての未処理データが確認されると、エンドポイントは、ピアから受信した最後の連続したTSNを累積TSN Ackフィールドに含めて、ピアにSHUTDOWNチャンクを送信します. 次に、T2シャットダウンタイマーを開始し、SHUTDOWN-SENT状態に入ります. タイマーが期限切れになった場合、エンドポイントは、ピアから受信した更新された最後の順次TSNでSHUTDOWNを再送信する必要があります. 

T2シャットダウンの適切なタイマー値を決定するには、セクション6.3の規則に従う必要があります. TSNのギャップを示すために、エンドポイントは同じSCTPパケットのSHUTDOWNチャンクにSACKをバンドルすることもできます. エンドポイントは、SHUTDOWNチャンクの再送信回数をプロトコルパラメータ「Association.Max.Retrans」に制限する必要があります. このしきい値を超えた場合、エンドポイントはTCBを破棄し、ピアエンドポイントが到達不能であることを上位層に報告する必要があります（したがって、関連付けはCLOSED状態になります）. ピアからのパケットの受信（つまり、ピアがキューに入れられたDATAチャンクのすべてを送信するとき）は、エンドポイントの再送信カウントをクリアし、T2シャットダウンタイマーを再起動して、キューに入れられたDATAチャンクのすべてを送信する十分な機会をピアに与える必要がありますまだ送信されていません. 

SHUTDOWNを受信すると、ピアエンドポイントは 

-SHUTDOWN-RECEIVED状態に入り、 

-SCTPユーザーからの新しいデータの受け入れを停止します.  

-チャンクの累積TSN Ackフィールドを確認して、SHUTDOWN送信者がその未処理のデータチャンクをすべて受信したことを確認します.  

エンドポイントがSHUTDOWN-RECEIVED状態に到達すると、ULP要求に応答してSHUTDOWNを送信してはならず、後続のSHUTDOWNチャンクを破棄する必要があります.  

まだ未解決のDATAチャンクが残っている場合、SHUTDOWN受信者は、未解決のすべてのDATAチャンクが確認されるまで、セクション6で定義された通常のデータ送信手順に従い続ける必要があります. ただし、SHUTDOWN受信者は、SCTPユーザーからの新しいデータを受け入れてはなりません. 

SHUTDOWN-SENT状態にある間、SHUTDOWN送信者は、1つ以上のDATAチャンクを含む各受信パケットにSHUTDOWNチャンクで即座に応答し、T2シャットダウンタイマーを再起動する必要があります. SHUTDOWNチャンクだけでは、受信したDATAチャンクのすべてを確認できない場合（つまり、確認可能なTSNが累積TSNより大きいため、TSNシーケンスにギャップが存在する場合）、または重複したTSNを受信した場合、次に、SACKチャンクも送信する必要があります. 

SHUTDOWNの送信者は、シャットダウンシーケンス全体の時間を制限するために、全体的なガードタイマー「T5-shutdown-guard」を開始することもできます. このタイマーの満了時に、送信者は、ABORTチャンクを送信することにより、関連付けを中止する必要があります. 「T5-shutdown-guard」タイマーを使用する場合、「RTO.Max」の5倍の推奨値に設定する必要があります. 

SHUTDOWNの受信側に未解決のDATAチャンクがない場合、SHUTDOWN受信側はSHUTDOWN ACKを送信し、独自のT2シャットダウンタイマーを開始して、SHUTDOWN-ACK-SENT状態に入る必要があります. タイマーが切れた場合、エンドポイントはSHUTDOWN ACKを再送信する必要があります. 

SHUTDOWN ACKの送信者は、SHUTDOWN ACKチャンクの再送信回数をプロトコルパラメータ「Association.Max.Retrans」に制限する必要があります. このしきい値を超えると、エンドポイントはTCBを破棄し、ピアエンドポイントが到達不能であることを上位層に報告する必要があります（したがって、関連付けはCLOSED状態になります）. 

SHUTDOWN ACKを受信すると、SHUTDOWN送信者はT2シャットダウンタイマーを停止し、SHUTDOWN COMPLETEチャンクをピアに送信し、関連付けのすべてのレコードを削除します.  

SHUTDOWN COMPLETEチャンクを受信すると、エンドポイントはSHUTDOWN-ACK-SENT状態にあることを確認します. そうでない場合は、チャンクを破棄する必要があります. エンドポイントがSHUTDOWN-ACK-SENT状態にある場合、エンドポイントはT2シャットダウンタイマーを停止し、関連付けのすべての情報を削除する必要があります（したがって、関連付けはCLOSED状態になります）. 

エンドポイントは、シャットダウン手順を開始する前に、すべての未処理のDATAチャンクが確認されていることを確認する必要があります.  

エンドポイントは、SHUTDOWN-PENDING、SHUTDOWN-SENT、SHUTDOWN-RECEIVED、またはSHUTDOWN-ACK-SENT状態の場合、上位層からの新しいデータ要求を拒否する必要があります.  

エンドポイントがSHUTDOWN-ACK-SENT状態にあり、この関連付けに属する送信元および宛先トランスポートアドレス（IPアドレスまたはINITチャンクのいずれか）でINITチャンクを受信する場合（たとえば、SHUTDOWN COMPLETEが失われた場合） 、INITチャンクを破棄し、SHUTDOWN ACKチャンクを再送信する必要があります.  

注：エンドポイントに割り当てられたトランスポートアドレスで使用されているのと同じ送信元IPアドレスと宛先IPアドレスを持つが、異なるポート番号を持つINITの受信は、個別のアソシエーションの初期化を示します.  

INITまたはCOOKIE ECHOの送信者は、SHUTDOWN ACKパケットで受信したのと同じタグに設定された共通ヘッダーの検証タグフィールドで、SCTPパケット内のスタンドアロンSHUTDOWN COMPLETEでSHUTDOWN ACKの受信に応答する必要があります. これは、セクション8.4で定義されているOut of the Blueパケットと見なされます. INITの送信者は、T1-initの実行を継続させ、COOKIE-WAITまたはCOOKIE-ECHOED状態のままにします. 通常のT1-initタイマーの期限切れにより、INITまたはCOOKIEチャンクが再送信され、新しい関連付けが開始されます. SHUTDOWNがCOOKIE-WAITまたはCOOKIE ECHOED状態で受信された場合、SHUTDOWNチャンクは静かに破棄されるべきです. 

エンドポイントがSHUTDOWN-SENT状態にあり、ピアからSHUTDOWNチャンクを受信した場合、エンドポイントはすぐにピアへのSHUTDOWN ACKで応答し、T2-shutdownタイマーを再起動してSHUTDOWN-ACK-SENT状態に移行します.  

エンドポイントがSHUTDOWN-ACK-SENT状態にあり、SHUTDOWN ACKを受信した場合、T2シャットダウンタイマーを停止し、SHUTDOWN COMPLETEチャンクをピアに送信し、関連付けのすべてのレコードを削除します.  

10.上位層とのインターフェース 

上位層プロトコル（ULP）は、プリミティブをSCTPに渡すことでサービスを要求し、さまざまなイベントについてSCTPから通知を受信します.  

このセクションで説明するプリミティブと通知は、SCTPを実装するためのガイドラインとして使用する必要があります. 以下のULPインターフェイスプリミティブの機能説明は、説明のために示されています. SCTPの実装が異なれば、ULPインターフェイスも異なる場合があります. ただし、すべてのSCTP実装が同じプロトコル階層をサポートできることを保証するために、すべてのSCTPは特定の最小限のサービスセットを提供する必要があります. 

10.1. ULP-to-SCTP

以下のセクションでは、ULP / SCTPインターフェースの機能を特徴付けます. 使用される表記は、高水準言語でのほとんどのプロシージャまたは関数呼び出しに似ています. 

以下で説明するULPプリミティブは、プロセス間通信をサポートするためにSCTPが実行する必要がある基本機能を指定します. 個々の実装は、独自の正確な形式を定義する必要があり、単一の呼び出しで基本機能の組み合わせまたはサブセットを提供できます. 

A）初期化 

形式：INITIALIZE（[ローカルポート]、[ローカル有効アドレスリスト]）->ローカルSCTPインスタンス名 

このプリミティブにより、SCTPは内部データ構造を初期化し、操作環境をセットアップするために必要なリソースを割り当てることができます. SCTPが初期化されると、ULPはこのプリミティブを再起動せずに他のエンドポイントと直接通信できます. 

SCTPはローカルSCTPインスタンス名をULPに返します. 必須属性：

なし.  

オプションの属性： 

次のタイプの属性をプリミティブとともに渡すことができます.  

oローカルポート-SCTPポート番号（ULPで指定する場合）.  

oローカル適格アドレスリスト-ローカルSCTPエンドポイントがバインドするアドレスリスト. デフォルトでは、アドレスリストが含まれていない場合、ホストに割り当てられたすべてのIPアドレスがローカルエンドポイントで使用される必要があります. 

実装注：このオプションの属性が実装でサポートされている場合、このエンドポイントによって送信されるSCTPパケットのIPソースアドレスフィールドに、ローカルの適格なアドレスで示されるIPアドレスの1つが含まれることを実施するのは実装の責任ですリスト.  

B）アソシエイト 

形式：ASSOCIATE（ローカルSCTPインスタンス名、宛先トランスポートaddr、アウトバウンドストリームカウント）->アソシエーションid [、destination transport addr list] [、outbound stream count] 

このプリミティブにより、上位層は特定のピアエンドポイントへの関連付けを開始できます.  

ピアエンドポイントは、エンドポイントを定義するトランスポートアドレスの1つによって指定されます（セクション1.3を参照）. ローカルSCTPインスタンスが初期化されていない場合、ASSOCIATEはエラーと見なされます. 

アソシエーションが正常に確立されると、SCTPアソシエーションのローカルハンドルであるアソシエーションIDが返されます. SCTPがピアエンドポイントとのSCTPアソシエーションを開くことができない場合、エラーが返されます. 

ピアの完全な宛先トランスポートアドレスやローカルエンドポイントのアウトバウンドストリームカウントなど、他の関連付けパラメーターが返される場合があります. 返された宛先アドレスからのトランスポートアドレスの1つが、SCTPパケットをこのピアに送信するためのデフォルトのプライマリパスとしてローカルエンドポイントによって選択されます. 返された「destination transport addr list」は、ULPがデフォルトのプライマリパスを変更したり、特定のトランスポートアドレスにパケットを強制的に送信したりするために使用できます. 

実装注：ASSOCIATEプリミティブがブロッキング関数呼び出しとして実装されている場合、ASSOCIATEプリミティブは、正常に確立されると、関連付けIDに加えて関連付けパラメーターを返すことができます. ASSOCIATEプリミティブが非ブロッキングコールとして実装されている場合、関連付けIDのみが返され、関連付けパラメータはCOMMUNICATION UP通知を使用して渡されます. 

必須属性： 

oローカルSCTPインスタンス名-INITIALIZE操作から取得.  

o宛先トランスポートaddr-アソシエーションが確立されるピアエンドポイントのトランスポートアドレスの1つとして指定されます.  

oアウトバウンドストリームカウント-ULPがこのピアエンドポイントに向けて開きたいアウトバウンドストリームの数.  

オプションの属性： 

なし.  

C）シャットダウン 

フォーマット：SHUTDOWN（association id）-> result 

関連付けを正常に閉じます. ローカルでキューに入れられたユーザーデータは、ピアに配信されます. アソシエーションは、ピアが送信されたすべてのSCTPパケットを確認した後にのみ終了します. 関連付けが正常に終了すると、成功コードが返されます. 関連付けを終了しようとして失敗した場合、エラーコードが返されます. 

必須属性： 

o association id-SCTPアソシエーションへのローカルハンドル.  

オプションの属性： 

なし.  





D）中止 

形式：ABORT（アソシエーションID [、上位レイヤー中止理由]）->結果 

アソシエーションを不正に閉じます. ローカルでキューに入れられたユーザーデータは破棄され、ABORTチャンクがピアに送信されます. 関連付けが正常に中止されると、成功コードが返されます. アソシエーションを中止しようとすると失敗に終わる場合、エラーコードが返されます. 

必須属性： 

o association id-SCTPアソシエーションへのローカルハンドル.  

オプションの属性： 

o上位層中止理由-ピアに渡される中止の理由.  

なし.  

E）送信 

形式：SEND（アソシエーションID、バッファアドレス、バイトカウント[、コンテキスト] [、ストリームID] [、ライフタイム] [、宛先トランスポートアドレス] [、無秩序フラグ] [バンドルなしフラグ] [、ペイロードプロトコルID ]）->結果 

これは、SCTPを介してユーザーデータを送信する主な方法です.  

必須属性： 

o association id-SCTPアソシエーションへのローカルハンドル.  

oバッファアドレス-送信されるユーザーメッセージが保存される場所.  

oバイトカウント-バイト数で表したユーザーデータのサイズ.  

オプションの属性： 

oコンテキスト-このユーザーメッセージの転送が失敗した場合にULPへの送信失敗通知で伝えられるオプションの32ビット整数 

oストリームID-データを送信するストリームを示します. 指定しない場合、ストリーム0が使用されます. oライフタイム-ユーザーデータのライフタイムを指定します. ユーザーデータは、有効期限が切れるとSCTPによって送信されません. このパラメーターを使用して、古いユーザーメッセージを送信する手間を回避できます. ライフタイム変数内でデータのトランスポートを開始できない場合（つまり、SCTPの送信プリミティブを介して宛先に送信できない場合）、SCTPはULPに通知します. ただし、有効期限が切れる前にSCTPがチャンクを送信しようとした場合、ユーザーデータが送信されます. 

実装ノート：データ寿命オプションをよりよくサポートするために、送信機は、TSN番号の最後の瞬間へのアウトバウンドDATAチャンクへの割り当てを保留することがあります. また、実装を簡単にするために、TSN番号が割り当てられると、送信者はこのDATAチャンクの送信をコミット済みと見なし、DATAチャンクに付加されたライフタイムオプションをオーバーライドする必要があります. 

o宛先トランスポートアドレス-このパケットの送信先となるピアエンドポイントの宛先トランスポートアドレスの1つとして指定されます. 可能な場合、SCTPは現在のプライマリパスの代わりに、パケットの送信にこの宛先トランスポートアドレスを使用する必要があります. 

o順序なしフラグ-このフラグは、存在する場合、ユーザーがデータを順序なしでピアに配信することを希望することを示します（つまり、このメッセージを運ぶすべてのDATAチャンクでUフラグが1に設定されます）.  

o no-bundleフラグ-このユーザーデータを他の発信DATAチャンクにバンドルしないようにSCTPに指示します. SCTPは、ネットワークの輻輳に直面したとき、このフラグが存在する場合でもバンドルすることができます. 

oペイロードprotocol-id-送信されるペイロードプロトコルデータのタイプを示すピアに渡される32ビットの符号なし整数. この値は、SCTPによって不透明なデータとして渡されます. 

F）プライマリを設定 

形式：SETPRIMARY（アソシエーションID、宛先トランスポートアドレス、[ソーストランスポートアドレス]）->結果 

指定した宛先トランスポートアドレスをパケット送信のプライマリパスとして使用するようにローカルSCTPに指示します.  

この操作を試行した結果が返されます. 指定された宛先トランスポートアドレスが、関連付けコマンドまたは通信アップ通知で以前に返された「宛先トランスポートアドレスリスト」に存在しない場合、エラーが返されます. 必須属性：

o association id-SCTPアソシエーションへのローカルハンドル.  

o宛先トランスポートアドレス-ピアエンドポイントのトランスポートアドレスの1つとして指定します. これは、パケットを送信するためのプライマリアドレスとして使用する必要があります. これは、ローカルSCTPエンドポイントによって維持されている現在のプライマリアドレス情報を上書きします. 

オプションの属性： 

o送信元トランスポートアドレス-オプションで、一部の実装では、すべての発信IPデータグラムに配置されるデフォルトの送信元アドレスを設定できます.  

G）受信 

形式：RECEIVE（アソシエーションID、バッファアドレス、バッファサイズ[、ストリームID]）->バイトカウント[、トランスポートアドレス] [、ストリームID] [、ストリームシーケンス番号] [、部分フラグ] [、配信番号] [、ペイロードプロトコルID] 

このプリミティブは、SCTPの最初のユーザーメッセージをULPで指定されたバッファーに読み込みます（使用可能なものがある場合）. 読み取られたメッセージのサイズ（バイト単位）が返されます. 特定の実装に応じて、送信者のアドレス、受信したストリームID、取得可能なメッセージが他にあるかどうかなど、他の情報も返す場合があります. 順序付けされたメッセージの場合、ストリームシーケンス番号も戻ってきた. 

実装に応じて、メッセージが利用できないときにこのプリミティブが呼び出される場合、実装はこの状態の表示を返すか、データが利用可能になるまで呼び出しプロセスをブロックする必要があります.  

必須属性： 

oアソシエーションid-SCTPアソシエーションへのローカルハンドル 

oバッファアドレス-受信したメッセージを保存するためにULPによって示されるメモリ位置.  

oバッファサイズ-受信するデータの最大サイズ（バイト単位）.  

オプションの属性： 

oストリームID-データを受信するストリームを示します. oストリームシーケンス番号-送信SCTPピアによって割り当てられたストリームシーケンス番号. 

o部分フラグ-この返されたフラグが1に設定されている場合、この受信にはメッセージ全体の部分配信が含まれます. このフラグが設定されると、ストリームIDとストリームシーケンス番号がこの受信に付随する必要があります. このフラグが0に設定されている場合、このストリームシーケンス番号の配信がこれ以上受信されないことを示します. 

ペイロードプロトコルID-受信したデータのペイロードプロトコルのタイプを示すピアから受信した32ビットの符号なし整数. この値は、SCTPによって不透明なデータとして渡されます. 

H）ステータス 

フォーマット：STATUS（association id）-> status data 

このプリミティブは、次の情報を含むデータブロックを返す必要があります.  

アソシエーション接続状態、宛先トランスポートアドレスリスト、宛先トランスポートアドレス到達可能性状態、現在の受信ウィンドウサイズ、現在の輻輳ウィンドウサイズ、未確認のDATAチャンクの数、受信保留中のDATAチャンクの数、プライマリパス、プライマリパスの最新のSRTT、RTOプライマリパス、他の宛先アドレス上のSRTTおよびRTOなど.  

必須属性： 

o association id-SCTPアソシエーションへのローカルハンドル.  

オプションの属性： 

なし.  

I）ハートビートの変更 

形式：CHANGE HEARTBEAT（アソシエーションID、宛先トランスポートアドレス、新しい状態[、間隔]）->結果 

指定された宛先トランスポートアドレスでハートビートを有効または無効にするようにローカルエンドポイントに指示します.  

この操作を試行した結果が返されます.  

注：宛先トランスポートアドレスがアイドル状態でない場合、有効にしてもハートビートは発生しません.  

必須属性： 

o association id-SCTPアソシエーションへのローカルハンドル.  

o宛先トランスポートアドレス-ピアエンドポイントのトランスポートアドレスの1つとして指定されます.  

o新しい状態-この宛先トランスポートアドレスのハートビートの新しい状態（有効または無効）.  

オプションの属性： 

o interval-存在する場合、宛先トランスポートアドレスでハートビートを有効にする場合、ハートビートの頻度を示します. この値は、宛先トランスポートアドレスのRTOに追加されます. この値が存在する場合、すべての宛先に影響します. 

J）HeartBeatをリクエストする 

形式：REQUESTHEARTBEAT（アソシエーションID、宛先トランスポートアドレス）->結果 

指定された関連付けの指定された宛先トランスポートアドレスでHeartBeatを実行するようにローカルエンドポイントに指示します. 返される結果は、宛先アドレスへのHEARTBEATチャンクの送信が成功したかどうかを示す必要があります. 

必須属性： 

o association id-SCTPアソシエーションへのローカルハンドル.  

o宛先トランスポートアドレス-ハートビートが発行されるアソシエーションのトランスポートアドレス.  

K）SRTTレポートを取得する 

形式：GETSRTTREPORT（アソシエーションID、宛先トランスポートアドレス）-> srtt result指定されたアソシエーションの指定された宛先トランスポートアドレスでの現在のSRTT測定を報告するようにローカルSCTPに指示します. 返される結果は、ミリ秒単位の最新のSRTTを含む整数です. 

必須属性： 

o association id-SCTPアソシエーションへのローカルハンドル.  

o宛先トランスポートアドレス-SRTT測定が報告されるアソシエーションのトランスポートアドレス.  

L）障害しきい値の設定 

形式：SETFAILURETHRESHOLD（アソシエーションID、宛先トランスポートアドレス、障害しきい値） 

->結果 

このプリミティブにより、ローカルSCTPは、指定された宛先アドレスの到達可能性障害検出しきい値「Path.Max.Retrans」をカスタマイズできます.  

必須属性： 

o association id-SCTPアソシエーションへのローカルハンドル.  

o宛先トランスポートアドレス-障害検出しきい値が設定されるアソシエーションのトランスポートアドレス.  

o失敗のしきい値-宛先アドレスの「Path.Max.Retrans」の新しい値.  

M）プロトコルパラメータの設定 

形式：SETPROTOCOLPARAMETERS（アソシエーションID、[、宛先トランスポートアドレス、]プロトコルパラメータリスト）->結果 

このプリミティブにより、ローカルSCTPはプロトコルパラメータをカスタマイズできます.  

必須属性： 

o association id-SCTPアソシエーションへのローカルハンドル.  



oプロトコルパラメータリスト-SCTPユーザーがカスタマイズしたいプロトコルパラメータの特定の名前と値（例：Association.Max.Retrans. セクション15を参照）.  

オプションの属性： 

o宛先トランスポートアドレス-プロトコルパラメータの一部は、宛先トランスポートアドレスごとに設定できます.  

N）未送信メッセージの受信 

形式：RECEIVE_UNSENT（データ取得ID、バッファアドレス、バッファサイズ[、ストリームID] [、ストリームシーケンス番号] [、部分フラグ] [、ペイロードプロトコルID]） 

oデータ取得ID-障害通知でULPに渡されたID.  

oバッファアドレス-受信したメッセージを保存するためにULPによって示されるメモリ位置.  

oバッファサイズ-受信するデータの最大サイズ（バイト単位）.  

オプションの属性： 

oストリームID-これは、データが送信されたストリームを示すために設定される戻り値です.  

oストリームシーケンス番号-この値は、メッセージに関連付けられたストリームシーケンス番号を示して返されます.  

o部分フラグ-この返されたフラグが1に設定されている場合、このメッセージはメッセージ全体の部分配信です. このフラグが設定されると、ストリームIDとストリームシーケンス番号がこの受信に付随する必要があります. このフラグが0に設定されている場合、このストリームシーケンス番号の配信がこれ以上受信されないことを示します. 

ペイロードプロトコルID-受信データのペイロードプロトコルのタイプを示すピアに送信されるために送信された32ビットの符号なし整数.  

o未確認メッセージを受信する 

形式：RECEIVE_UNACKED（データ取得ID、バッファアドレス、バッファサイズ、[、ストリームID] [、ストリームシーケンス番号] [、部分フラグ] [、ペイロードプロトコルID]） 

oデータ取得ID-障害通知でULPに渡されたID.  

oバッファアドレス-受信したメッセージを保存するためにULPによって示されるメモリ位置.  

oバッファサイズ-受信するデータの最大サイズ（バイト単位）.  

オプションの属性： 

oストリームID-これは、データが送信されたストリームを示すために設定される戻り値です.  

oストリームシーケンス番号-この値は、メッセージに関連付けられたストリームシーケンス番号を示して返されます.  

o部分フラグ-この返されたフラグが1に設定されている場合、このメッセージはメッセージ全体の部分配信です. このフラグが設定されると、ストリームIDとストリームシーケンス番号がこの受信に付随する必要があります. このフラグが0に設定されている場合、このストリームシーケンス番号の配信がこれ以上受信されないことを示します. 

oペイロードプロトコルID-受信データのペイロードプロトコルのタイプを示すピアに送信された32ビットの符号なし整数.  

P）SCTPインスタンスを破棄する 

形式：DESTROY（ローカルSCTPインスタンス名） 

oローカルSCTPインスタンス名-これは、初期化プリミティブでアプリケーションに渡された値であり、どのSCTPインスタンスが破棄されるかを示します.  

10.2. SCTP-to-ULP

オペレーティングシステムまたはアプリケーション環境は、SCTPがULPプロセスに非同期的に信号を送る手段を提供すると想定されています. SCTPがULPプロセスに信号を送ると、特定の情報がULPに渡されます. 

実装に関する注：場合によっては、別のソケットまたはエラーチャネルを介してこれを行うことができます.  







A）データ到着通知 

SCTPは、ユーザーメッセージが正常に受信され、取得の準備ができたときに、ULPでこの通知を呼び出します.  

オプションで通知とともに次のものを渡すことができます.  

o association id-SCTPアソシエーションへのローカルハンドル.  

oストリームID-データが受信されるストリームを示します.  

B）障害通知の送信 

メッセージを配信できない場合、SCTPはULPでこの通知を呼び出します.  

オプションで通知とともに次のものを渡すことができます.  

o association id-SCTPアソシエーションへのローカルハンドル.  

oデータ取得ID-未送信および未確認のデータを取得するために使用されるID.  

o原因コード-サイズが大きすぎる、メッセージの有効期限が切れているなど、失敗の理由を示す 

oコンテキスト-このメッセージに関連付けられたオプションの情報（セクション10.1のDを参照）.  

C）ネットワークステータス変更通知 

宛先トランスポートアドレスが非アクティブとマークされた場合（SCTPが障害を検出した場合など）、またはアクティブとマークされた場合（SCTPが回復を検出した場合など）、SCTPはULPでこの通知を呼び出します.  

以下は通知とともに渡されます.  

o association id-SCTPアソシエーションへのローカルハンドル.  

o宛先トランスポートアドレス-これは、変更の影響を受けるピアエンドポイントの宛先トランスポートアドレスを示します.  

o new-status-これは新しいステータスを示します.  









D）コミュニケーションアップ通知 

この通知は、SCTPがユーザーメッセージを送受信できる状態になったとき、またはエンドポイントへの失われた通信が復元されたときに使用されます.  

実装に関する注：ASSOCIATEプリミティブがブロッキング関数呼び出しとして実装されている場合、ASSOCIATEプリミティブ自体の結果として関連付けパラメーターが返されます. その場合、アソシエーションのイニシエーター側では、COMUPNICATION UP通知はオプションです. 

以下は通知とともに渡されます.  

o association id-SCTPアソシエーションへのローカルハンドル.  

o status-これは、発生したイベントのタイプを示します.  

o宛先トランスポートアドレスリスト-ピアのトランスポートアドレスの完全なセット.  

oアウトバウンドストリームカウント-ULPがこのアソシエーションで使用できるストリームの最大数.  

oインバウンドストリームカウント-ピアエンドポイントがこのアソシエーションで要求したストリームの数（これは「アウトバウンドストリームカウント」と同じ数ではない場合があります）.  

E）通信喪失通知 

SCTPがエンドポイントとの通信を完全に失った場合（たとえば、ハートビート経由）、またはエンドポイントが中止操作を実行したことを検出すると、ULPでこの通知を呼び出します.  

以下は通知とともに渡されます.  

o association id-SCTPアソシエーションへのローカルハンドル.  

oステータス-これは、発生したイベントのタイプを示します. ステータスは、シャットダウンまたは中止要求に応じて、障害または通常の終了イベントが発生したことを示す場合があります. 

以下が通知とともに渡される場合があります.  

oデータ取得ID-未送信および未確認のデータを取得するために使用されるID.  

o last-acked-そのピアエンドポイントによって最後に確認応答されたTSN.  

o last-sent-そのピアエンドポイントに最後に送信されたTSN.  

o上位層中止理由-ユーザーが開始した中止の場合に指定された中止理由.  

F）通信エラー通知 

SCTPは、ピアからERRORチャンクを受信し、ULPに通知することを決定すると、ULPでこの通知を呼び出すことができます.  

通知とともに次のものを渡すことができます.  

o association id-SCTPアソシエーションへのローカルハンドル.  

oエラー情報-これは、エラーのタイプと、オプションでERRORチャンクを通じて受信した追加情報を示します.  

G）再起動通知 

SCTPは、ピアが再起動したことを検出すると、この通知をULPに送信する場合があります.  

通知とともに次のものを渡すことができます.  

o association id-SCTPアソシエーションへのローカルハンドル.  

H）シャットダウン完了通知 

SCTPがシャットダウン手順（9.2項）を完了すると、この通知は上位層に渡されます.  

通知とともに次のものを渡すことができます.  

o association id-SCTPアソシエーションへのローカルハンドル.  

11.セキュリティに関する考慮事項 

11.1. セキュリティ対策方針

2つのネットワーク化されたエンドポイント間で、テレフォニーサービスの請求やシグナリングメッセージなど、時間に依存するユーザーメッセージを確実に伝送するように設計された一般的なトランスポートプロトコルとして、SCTPには次のセキュリティ対策方針があります.  

-信頼できるタイムリーなデータ転送サービスの可用性 

-SCTPによって伝達されるユーザー間情報の整合性 

11.2. 潜在的な脅威に対するSCTPの対応

SCTPは、さまざまなリスク状況で使用される可能性があります. SCTPを実行しているシステムの運用者は、特定の状況を分析し、適切な対策を決定することが重要です. 

SCTPを実行しているシステムのオペレータは、サイトのセキュリティ保護に関するガイダンスについて[RFC2196]を参照する必要があります.  

11.2.1. インサイダー攻撃に対抗する

[RFC2196]の原則は、インサイダーによる情報の盗難または妨害のリスクを最小限に抑えるために適用されるべきです. このような手順には、セキュリティポリシーの公開、物理、ソフトウェア、およびネットワークレベルでのアクセスの制御、およびサービスの分離が含まれます. 

11.2.2. ネットワーク内のデータ破損からの保護

下位層のトランスポートサービスによって配信されるデータグラムで検出されないエラーのリスクが大きすぎると見なされる場合、追加の整合性保護が必要です. この追加の保護がアプリケーション層で提供された場合、SCTPヘッダーは意図的な整合性攻撃に対して脆弱なままです. パケットリプレイを検出するための既存のSCTPメカニズムは通常の操作には十分であると考えられますが、操作環境に高度な敵からの意図的な攻撃の重大なリスクが含まれる場合、SCTPを保護するにはより強力な保護が必要です. 

SCTP認証拡張機能SCTP-AUTH [RFC4895]は、脅威環境がより強力な整合性保護を必要とするが、機密性を必要としない場合に使用できます（MAY）.  

11.2.3. 機密性の保護

ほとんどの場合、機密性の侵害のリスクは、SCTPまたは下位層のプロトコルオーバーヘッドではなく、シグナリングデータペイロードに適用されます. それが当てはまる場合、SCTPユーザーデータの暗号化のみが考慮される可能性があります. 補足チェックサムサービスと同様に、ユーザーデータの暗号化はSCTPユーザーアプリケーションによって実行される場合があります. または、ユーザーアプリケーションは実装固有のAPIを使用して、IPカプセル化セキュリティペイロード（ESP）[RFC4303]を使用して機密性と整合性を提供するように要求することができます. 



特にモバイルユーザーの場合、機密性の要件には、IPアドレスとポートのマスキングが含まれる場合があります. この場合、アプリケーションレベルの機密性の代わりにESPを使用する必要があります. ESPを使用してSCTPトラフィックの機密性を保護する場合、機密性の脅威がある場合は強力な整合性の脅威もあるため、暗号の整合性保護を含むESP暗号変換を使用する必要があります. 

ESPが使用されているときは常に、アプリケーションレベルの暗号化は通常必要ありません.  

機密性が提供される場所に関係なく、インターネットキー交換プロトコルバージョン2（IKEv2）[RFC4306]をキー管理に使用する必要があります.  

オペレータは、インターネットプロトコル層で、およびそのすぐ上で利用可能なセキュリティサービスの詳細について[RFC4301]を参照する必要があります.  

11.2.4. ブラインドサービス拒否攻撃からの保護

ブラインド攻撃とは、攻撃者がターゲットSCTPノードとの間でやり取りされるデータフローのコンテンツを傍受したり、見たりすることができない攻撃です. ブラインドサービス拒否攻撃には、フラッディング、マスカレード、またはサービスの不適切な独占という形があります. 

11.2.4.1. 洪水

フラッディングの目的は、リソースの枯渇、正当なトランザクションへの干渉、バッファ関連のソフトウェアバグの悪用を通じて、ターゲットシステムでサービスの損失と不正な動作を引き起こすことです. フラッディングは、SCTPノード、または介在するIPアクセスリンクまたはインターネットのリソースのいずれかに向けられます. 後者のエンティティがターゲットである場合、フラッディングはネットワークサービスの損失として現れます. これには、設置されているファイアウォールの侵害が潜在的に含まれます. 

一般に、フラッディングに対する保護は機器設計レベルで始まり、次のような対策が含まれます.  

-サービスのリクエストが正当であると判断する前に、限られたリソースのコミットメントを回避します.  

-新しい作業の受け入れよりも進行中の処理の完了を優先する.  

-サービスの重複または失効したキュー要求の識別と削除. -非ユニキャストアドレスに送信された予期しないパケットに応答しない. 

ネットワーク機器は、トラフィックの疑わしい増加が発生した場合にアラームとログを生成できる必要があります. ログには、ネットワークまたはSCTPシステムオペレーターが保護対策を講じるのに役立つ着信リンクのIDや使用された送信元アドレスなどの情報が含まれている必要があります. 明らかな悪用パターンが明らかになった場合、オペレーターがそのようなアラームに対処するための手順を整える必要があります. 

SCTPの設計は、特に4ウェイスタートアップハンドシェイクの使用、応答するSCTPノードでのハンドシェイクが完了するまでリソースのコミットメントを延期するためのCookieの使用、および検証タグの使用において、フラッディング攻撃に対して耐性があります. 確立されたアソシエーションのフローへの無関係なパケットの挿入を防ぎます.  

IP認証ヘッダーとカプセル化セキュリティペイロードは、特定の種類のサービス拒否攻撃のリスクを減らすのに役立つ場合があります. 

INITチャンクでのホスト名機能の使用は、ターゲットDNSサーバーをフラッディングするために使用できます. INITチャンクで受信したホスト名をIPアドレスに解決するDNSクエリの大量のバックログは、特定のドメイン内の複数のホストにINITを送信することで実現できます. さらに、攻撃者は、ターゲットのホスト名を含むランダムなホストに多数のINITを送信することにより、第三者に対する間接攻撃でホスト名機能を使用する可能性があります. DNSリソースへの負荷に加えて、これは多数のINIT ACKがターゲットに送信されることにもなります. このタイプの攻撃から保護する1つの方法は、DNSから受信したIPアドレスに元のINITのソースIPアドレスが含まれていることを確認することです. DNSから受信したIPアドレスのリストにINITのソースIPアドレスが含まれていない場合、エンドポイントはINITを静かに破棄する場合があります. この最後のオプションは、DNSに対する攻撃から保護しません. 

11.2.4.2. ブラインドマスカレード

マスカレードは、いくつかの方法でサービスを拒否するために使用できます.  

-偽装されたノードのアクセスが制限されているターゲットSCTPノードでリソースを結び付けることにより. たとえば、ターゲットノードは、ポリシーにより、偽装SCTPノードとの最大1つのSCTPアソシエーションを許可できます. なりすまし攻撃者は、偽装されたノードから来るとされるアソシエーションを確立しようとする可能性があります. 

-偽装を意図的に検出できるようにすることにより、偽装されたノードがターゲットSCTPノードからロックアウトされる原因となる対策を引き起こします.  

-SHUTDOWNリクエストなどの無関係なコンテンツを挿入することにより、確立された関連付けを妨害する.  

SCTPは、4ウェイスタートアップハンドシェイクを使用して、IPスプーフィングによるブラインドマスカレード攻撃のリスクを軽減します. 最初の交換ではメモリがなくなるため、ブラインドマスカレード攻撃によってロックアウトメカニズムがトリガーされることはありません. さらに、状態Cookieを含むINIT ACKは、INITを受信したIPアドレスに送信されます. したがって、攻撃者は状態Cookieを含むINIT ACKを受信しません. SCTPは、検証タグの使用により、確立されたアソシエーションのフローへの無関係なパケットの挿入を防ぎます. 

受信したINIT要求および予期しないINIT ACKなどの異常のロギングは、悪意のあるアクティビティのパターンを検出する方法と見なされる場合があります. ただし、このようなロギングの潜在的な有用性は、SCTPノードがフラッディング攻撃に対してより脆弱になるため、SCTP起動処理の増加と比較検討する必要があります. 日常的にログを確認および分析するための操作手順を確立しなければ、ロギングは無意味です. 

11.2.4.3. サービスの不適切な独占

この見出しの下での攻撃は、攻撃者によって公然と合法的に実行されます. それらは、ターゲットSCTPノードまたは攻撃者とターゲットノード間の共有リソースの仲間のユーザーを対象としています. 可能な攻撃には、攻撃者のノードとターゲットの間の多数のアソシエーションのオープン、または合法的に確立されたアソシエーション内の大量の情報の転送が含まれます. 

ポリシーの制限は、隣接するSCTPノードごとの関連付けの数に設定する必要があります. SCTPユーザーアプリケーションは、ローカルポリシーに基づいて、特定のアソシエーション内の大量の不正または「no-op」メッセージを検出し、その結果としてアソシエーションをログ記録または終了できる必要があります. 

11.3. SCTPとファイアウォールの相互作用

一部のファイアウォールでは、フラグメント化されたSCTPパケットの最初のフラグメントのみを検査し、それがINITチャンクに対応するかどうかを明確に判断できれば役立ちます（詳細については[RFC1858]を参照してください）. したがって、セクション3.1で述べられている要件を強調します. （1）INITチャンクはパケット内の他のチャンクとバンドルしてはならず、（2）INITチャンクを含むパケットにはゼロ検証タグがなければなりません. さらに、INITチャンクの受信者は、他のチャンクにバンドルされているか、ゼロ以外の検証タグを持ち、INITチャンクを含むINITチャンクを持つ到着パケットを静かに破棄することにより、これらのルールを実施する必要があります. 

11.4. 非SCTP対応ホストの保護

SCTP対応ホストと同じレベルの攻撃に対する保護を非SCTP対応ホストに提供するには、すべてのSCTPスタックが付録Cで説明されているICMP処理を実装しなければなりません.  

SCTPスタックが複数の制御チャンクまたはDATAチャンクを含むパケットを受信し、パケットの処理に応答して複数のチャンクを送信する必要がある場合、応答チャンクの送信者は複数のパケットを送信してはなりません. バンドルがサポートされている場合、1つのパケットに収まる複数の応答チャンクを1つの単一の応答パケットにバンドルすることができます. バンドリングがサポートされていない場合、送信者は複数の応答チャンクを送信してはならず、他のすべての応答を破棄しなければなりません. SACKチャンク自体はDATAへの応答であり、SACKはそれ以上のDATAの応答を必要としないため、この規則はSACKチャンクには適用されないことに注意してください. 

SCTP実装は、送信されていないTSNを確認するSACKを受信した場合、アソシエーションを中止する必要があります.  

複数のERRORパラメーターが含まれているため、応答で大きなパケットを必要とするINITを受信するSCTP実装では、（任意で）ERRORパラメーターの一部またはすべてを省略してINIT ACKのサイズを小さくすることを選択できます. COOKIEパラメータのサイズと、INITの受信者がピアに示すアドレスの数の組み合わせにより、INIT ACKが元のINITよりも大きくなる可能性が常にあります. SCTP実装は、バイト増幅攻撃の可能性を減らすために、INIT ACKをできるだけ小さくしようとする必要があります. 

12.ネットワーク管理の考慮事項 

[RFC3873]で定義されたSCTPのMIBモジュールは、このドキュメントで指定されたプロトコルのバージョンに適用されます.  











13.推奨される伝送制御ブロック（TCB）パラメーター 

このセクションでは、実装のためにTCB内に含める必要のある推奨パラメーターセットについて詳しく説明します. このセクションは説明のためのものであり、実装の要件またはSCTP TCB内のすべてのパラメーターの完全なリストと見なされるべきではありません. 各実装には、最適化のために独自の追加パラメーターが必要になる場合があります. 

13.1. SCTPインスタンスに必要なパラメーター

関連付け：現在の関連付けと各関連付けのデータコンシューマーへのマッピングのリスト. これは、ハッシュテーブルまたは他の実装依存構造の形式である場合があります. データコンシューマは、SCTPの実装方法に応じて、ファイル記述子、名前付きパイプポインター、テーブルポインターなどのプロセス識別情報である場合があります. 

秘密鍵：このエンドポイントがMACを計算するために使用する秘密鍵. これは、十分な長さの暗号品質の乱数である必要があります. キーの選択には、RFC 4086の説明が役立ちます. 

アドレスリスト：このインスタンスがバインドしたIPアドレスのリスト. この情報は、INITおよびINIT ACKチャンクでピアに渡されます. 

SCTPポート：エンドポイントがバインドされているローカルSCTPポート番号.  

13.2. 関連付けごとに必要なパラメーター（つまり、TCB）

ピア：すべてのパケットで送信され、受信されるタグ値検証：INITまたはINIT ACKチャンクで. 鬼ごっこ ：

My：すべてのインバウンドパケットでタグが期待され、検証で送信された：INITまたはINIT ACKチャンク. 鬼ごっこ ：

状態：関連付けがどの状態にあるかを示す状態変数：すなわち、COOKIE-WAIT、COOKIE-ECHOED、ESTABLISHED 、: SHUTDOWN-PENDING、SHUTDOWN-SENT、SHUTDOWN-RECEIVED 、: SHUTDOWN-ACK-SENT.  

注：アソシエーションが「クローズ」されている場合、そのTCBは削除されるべきであるため、「クローズ」状態は示されていません. ピア：ピアTransport：がバインドされているSCTPトランスポートアドレスのリスト. この情報は、INITまたはAddress：INIT ACKから派生し、着信パケットList：を特定の関連付けに関連付けるために使用されます. 通常、この情報は：TCBの迅速な検索とアクセスのためにハッシュまたはキー化されます. 

プライマリ：これは現在のプライマリ宛先トランスポートですパス：ピアエンドポイントのアドレス. このエンドポイントの送信元トランスポートアドレスも指定できます. 

全体：全体的なアソシエーションエラーカウント. エラー数：

全体：この関連付けのしきい値により、全体のエラー：エラーカウントに達すると、この関連付けがしきい値：破棄されます.  

Peer Rwnd：ピアのrwndの現在の計算値.  

次のTSN：新しいDATAチャンクに割り当てられる次のTSN番号. ：これはINITまたはINIT ACKチャンクでピアに送信され、DATAチャンクにTSNが割り当てられるたびに増加します（通常、送信前または送信中にフラグメンテーション）. 

Last Rcvd：これは、最後に受信したTSNです. この値TSN：ピアの初期TSNを取得することで最初に設定されます. ：INITまたはINIT ACKチャンクで受信され、それから1を減算します. 

マッピング：どの配列外の順序TSNが受信されたかを示すビットまたはバイトの配列（最後のRcvd TSNに関連）. ギャップが存在しない場合、つまり順序​​外のパケットが受信されていない場合、この配列はすべてゼロに設定されます. この構造は、循環バッファまたはビット配列の形式になります. 

Ack State：このフラグは、次の受信パケットがSACKで応答されるかどうかを示します. これは初期化されます：0に. パケットが受け取られるときそれは増分されます. ：この値が2以上に達すると、SACKが送信され、値が0にリセットされます. 注：これは、データチャンクが順不同で受信された場合にのみ使用されます. DATA：チャンクが故障している場合、SACKは遅延しません（セクション6を参照）. 



Inbound：インバウンドストリームを追跡する構造体の配列. Streams：通常、予想される次のシーケンス番号と、場合によってはストリーム番号を含みます.  

アウトバウンド：アウトバウンドストリームを追跡する構造体の配列. Streams：通常、次のシーケンス番号を含む：ストリームで送信されます.  

Reasm Queue：再構成キュー.  

Local：このTransport：アソシエーションにバインドされたローカルIPアドレスのリスト. 住所：リスト：

アソシエーション：すべてのPMTUで発見された最小のPMTU：ピアのトランスポートアドレス.  

13.3. トランスポートごとの住所データ

INITまたはINIT ACKチャンクから派生したピアのアドレスリスト内の各宛先トランスポートアドレスについて、次のような多くのデータ要素を維持する必要があります.  

エラー数：この宛先の現在のエラー数.  

エラー：この宛先の現在のエラーしきい値、つまり、しきい値：エラーカウントがこの値に達した場合に宛先をマークダウンする値.  

cwnd：現在の輻輳ウィンドウ.  

ssthresh：現在のssthresh値.  

RTO：現在の再送信タイムアウト値.  

SRTT：現在の平滑化された往復時間.  

RTTVAR：現在のRTTバリエーション.  

partial：確認されたバイト数でのcwndの増加の追跡方法：輻輳回避モード（セクション7.2.2を参照）.  

state：この宛先の現在の状態、つまり、DOWN、UP 、: ALLOW-HB、NO-HEARTBEATなど.  





PMTU：現在の既知のパスMTU.  

Per：各宛先で使用されるタイマー. 宛先：タイマー：

RTO-Pending：送信されたDATAチャンクの1つが現在RTTの計算に使用されているかどうかを追跡するために使用されるフラグ. このフラグが0の場合、送信先の次のDATAチャンクは、この宛先を使用してRTTを計算する必要があり、このフラグを設定する必要があります. RTT：計算が完了するたびに（つまり、DATAチャンクがSACKされます）、このフラグをクリアします. 

last-time：この宛先が最後に送信された時刻. ：これは、ハートビートが必要かどうかを判断するためのものです. 

13.4. 必要な一般的なパラメーター

Out Queue：アウトバウンドDATAチャンクのキュー.  

In Queue：インバウンドDATAチャンクのキュー.  

14. IANAの考慮事項 

SCTPは、IANAが管理する3つのレジストリを定義します.  

-追加のチャンクタイプの定義、-追加のパラメータータイプの定義、または-ERRORチャンク内の追加の原因コードの定義.  

SCTPでは、SCTPポート登録のためにIANAポート番号レジストリを開く必要があります. セクション14.5でその方法を説明します. IESGが任命したExpert Reviewerは、SCTPポート割り当て要求の評価においてIANAをサポートします. 

14.1. IETF定義のチャンク拡張

[RFC2434]で定義されているように、新しいチャンクパラメータタイプコードの割り当ては、IETFコンセンサスアクションを通じて行われます. チャンクパラメータのドキュメントには、次の情報を含める必要があります. 

a）新しいチャンクタイプの長い名前と短い名前.  

b）チャンクの構造の詳細な説明. セクション3.2で定義された基本構造に準拠しなければなりません.  



c）チャンク内の各フィールドの使用目的の詳細な定義と説明（ある場合はチャンクフラグを含む）.  

d）プロトコルの動作内での新しいチャンクタイプの使用に関する詳細な手順説明.  

最後のチャンクタイプ（255）は、必要に応じて将来の拡張用に予約されています.  

14.2. IETF定義のチャンクパラメータ拡張

新しいチャンクパラメータタイプコードの割り当ては、[RFC2434]で定義されているIETFコンセンサスアクションを通じて行われます. チャンクパラメータのドキュメントには、次の情報を含める必要があります. 

a）パラメータタイプの名前.  

b）パラメータフィールドの構造の詳細な説明. この構造は、セクション3.2.1で説明されている一般的なType-Length-Value形式に準拠する必要があります. 

c）パラメータ値の各コンポーネントの詳細な定義.  

d）このパラメータタイプの使用目的の詳細な説明、およびこのパラメータタイプの複数のインスタンスが同じチャンク内で見つかるかどうか、またどのような状況で見つかるかを示す.  

e）各パラメータタイプは、すべてのチャンクにわたって一意でなければなりません.  

14.3. IETF定義の追加エラーの原因

追加の原因コードは、[RFC2434]で定義されているように、仕様要求アクションを通じて11から65535の範囲で割り当てられます. 提供されるドキュメントには、次の情報が含まれている必要があります. 

a）エラー状態の名前.  

b）SCTPエンドポイントがこの原因コードでERROR（またはABORT）を発行する条件の詳細な説明.  

c）この原因コードを含むERROR（またはABORT）チャンクを受信するSCTPエンドポイントによる予期されるアクション.  

d）この原因コードに付随するデータフィールドの構造と内容の詳細な説明.  



原因コードパラメータの最初の単語（32ビット）は、セクション3.3.10に示されている形式に準拠する必要があります.  

-最初の2バイトには原因コード値が含まれます-最後の2バイトには原因パラメーターの長さが含まれます.  

14.4. ペイロードプロトコル識別子

SCTPがDATAチャンク内の未指定のペイロードプロトコル識別子を示すために予約されている値0を除き、SCTPはペイロードプロトコル識別子の標準化または検証を行いません. SCTPは、単に上位層から識別子を受け取り、対応するペイロードデータとともにそれを運びます. 

上位層、つまりSCTPユーザーは、必要に応じて特定のプロトコル識別子をIANAで標準化する必要があります（SHOULD）. 特定のペイロードプロトコル識別子の使用は、SCTPの範囲外です. 

14.5. ポート番号レジストリ

SCTPサービスは、TCPおよびUDPのように、不明な発信​​者にサービスを提供するために連絡先ポート番号を使用する場合があります. したがって、IANAは、次のルールを使用してSCTPの既存のポート番号レジストリを開くように要求されます. これらのルールは、既存のポート番号登録手順とうまく一致する予定です. IESGが任命したExpert Reviewerは、[RFC2434]で定義された手順に従って、SCTPポート割り当て要求の評価においてIANAをサポートします. 

ポート番号は3つの範囲に分かれています. 既知のポートは0から1023まで、登録済みのポートは1024から49151まで、動的および/またはプライベートポートは49152から65535までのポートです. 既知の登録済みポートは、希望するサーバーアプリケーションで使用するためのものです. システムのデフォルトの連絡先. ほとんどのシステムでは、Well Knownポートはシステム（またはルート）プロセスまたは特権ユーザーが実行するプログラムでのみ使用できますが、登録ポートは通常のユーザープロセスまたは通常ユーザーが実行するプログラムで使用できます. 動的ポートおよび/またはプライベートポートは、クライアント側のポート、帯域外のネゴシエートされたポート、専用ポートの登録前のアプリケーションテストなど、一時的な使用を目的としています. 登録してはいけません. 

ポート番号レジストリは、Well Known PortsおよびRegistered Portsの範囲のSCTPポートの登録を受け入れる必要があります. 既知の登録済みポートは、登録なしでは使用しないでください. TCPからSCTPへのアプリケーションの移植など、場合によっては、登録が完了する前にSCTPポートを使用するのが自然に思えるかもしれませんが、IANAは

特定の既知の登録済みポート. 登録はできるだけ早く要求されるべきです. 

各ポート登録には、次の情報が含まれる必要があります.  

o文字（A〜Zおよびa〜z）、数字（0〜9）、および「-_ +. / *」からの句読文字（引用符を除く）のみで構成される短いポート名.  

o登録のために要求されるポート番号.  

oポートの目的を説明する短い英語のフレーズ.  

o登録を実行する個人またはエンティティの名前と連絡先情報、および場合によってはポートの使用を定義するドキュメントへの参照. IETFワーキンググループからの登録では、ワーキンググループに名前を付けるだけで済みますが、連絡先を示すことをお勧めします. 

登録者は、登録を提出する際にこれらのガイドラインに従うことをお勧めします.  

oポート名は、複数のSCTPポート番号に登録されるべきではありません.  

o TCPに登録されたポート名は、SCTPにも登録される場合があります. そのような登録は、既存のTCP登録と同じポート番号を使用する必要があります. 

oポートを使用する具体的な意図は、ポート登録に先行する必要があります. たとえば、既存のTCPポートは、これらのポートをSCTPに使用する意図に先立って登録されるべきではありません（SHOULD NOT）. 

このドキュメントでは、次のポートを登録します. （これらの登録は、将来の割り当て要求のために従うモデルと見なされる必要があります. ）

discard 9 / sctp Discard＃IETF TSVWG＃Randall Stewart <rrs@cisco.com>＃[RFC4960] 

ポート9でSCTP接続を受け入れる破棄サービスは、着信アプリケーションデータをすべて破棄し、応答としてデータを送信しません. したがって、SCTPの破棄ポートはTCPの破棄ポートに類似しており、SCTPスタックの状態を確認するために使用される場合があります. 



ftp-data 20 / sctp FTP＃IETF TSVWG＃Randall Stewart <rrs@cisco.com>＃[RFC4960] 

ftp 21 / sctp FTP＃IETF TSVWG＃Randall Stewart <rrs@cisco.com>＃[RFC4960] 

ファイル転送プロトコル（FTP）データ（20）および制御ポート（21）.  

ssh 22 / sctp SSH＃IETF TSVWG＃Randall Stewart <rrs@cisco.com>＃[RFC4960] 

Secure Shell（SSH）リモートログインサービス. ホストへのセキュアシェルログインを許可します.  

http 80 / sctp HTTP＃IETF TSVWG＃Randall Stewart <rrs@cisco.com>＃[RFC4960] 

SCTP上のWorld Wide Web HTTP.  

bgp 179 / sctp BGP＃IETF TSVWG＃Randall Stewart <rrs@cisco.com>＃[RFC4960] 

SCTP上のボーダーゲートウェイプロトコル.  

https 443 / sctp HTTPS＃IETF TSVWG＃Randall Stewart <rrs@cisco.com>＃[RFC4960] 

SCTP上のTLS / SSL上のWorld Wide Web HTTP.  

15.推奨されるSCTPプロトコルパラメータ値 

次のプロトコルパラメータが推奨されます.  

RTO.Initial-3秒RTO.Min-1秒RTO.Max-60秒Max.Burst-4 RTO.Alpha-1/8 RTO.Beta-1/4 Valid.Cookie.Life-60秒Association.Max.Retrans -10回の試行Path.Max.Retrans-5回の試行（宛先アドレスごと）Max.Init.Retransmits-8回の試行HB.interval-30秒HB.Max.Burst-1 

実装注：SCTP実装により、ULPはこれらのプロトコルパラメータの一部をカスタマイズできる場合があります（セクション10を参照）.  

注：RTO.Minは、上記の推奨事項に従って設定する必要があります.  

16.謝辞 

この更新されたドキュメントによって表される事業は、小さな偉業ではなく、RFC 2960の初期著者の要約です. Q. Xie、K. Morneault、C. Sharp、H. Schwarzbauer、T. Taylor、I. Rytina、M.  Kalla、L. Zhang、およびV. Paxson.  

さらに、元のRFCに貢献したすべての人からのコメント： 

マーク・オールマン、RJアトキンソン、リチャード・バンド、スコット・ブラッドナー、スティーブ・ベロビン、ピーター・バトラー、ラム・ダントゥ、R. ・エジルパバイ、マイク・フィスク、サリー・フロイド、福本At、マット・ホールドリージ、ヘンリー・ハウ、クリスチャン・ホイテマ、ゲイリー・レヘカ、ジョナサン・リー、デヴィッドレーマン、ジョン・ローニー、ダニエル・ルアン、バリー・ナゲルバーグ、トーマス・ナルテン、エリック・ノルドマーク、リンドン・オング、シャヤル・プラサド、ケルビン・ポーター、ハインツ・プラントナー、ヤルノ・ラジャハルム、レイモンド・E・リーブス、レニー・レヴィス、イヴァン・アリアス・ロドリゲス、A. サンカール、グレッグ・サイドボット、ブライアンワイルド、ラモンテヤロール、その他の多くの貴重なコメントをいただきました.  

次に、SCTP実装ガイドの作成者であるI.アリアスロドリゲス、K. プーン、A. カロ、およびM.テクセンを追加します.  

次に、これらのすべての後続の7つのSCTP相互運用性テストの努力と、謝辞に示されているようにRFC 4460にコメントした人々の努力を追加します.  

バリー・ザッカーマン、ラ・モンテ・ヤロル、チャオビン・シェ、ワン・シャオペン、ジョナサン・ウッド、ジェフ・ワスコウ、マイク・ターナー、ジョン・タウンゼンド、サビーナ・トレンテ、クリフ・トーマス、鈴木裕司、マノジ・ソランキ、スヴェレ・スロット、キール・シャー、ヤン・ロビンス、ベン・ロビンソン、レニーRevis、Ian Periam、RC Monee、Sanjay Rao、Sujith Radhakrishnan、Heinz Prantner、Biren Patel、Nathalie Mouellic、Mitch Miers、Bernward Meyknecht、Stan McClellan、Oliver Mayor、Tomas Orti Martin、Sandeep Mahajan、David Lehmann、Jonathan Lee、Philippe Langlois 、カール・ナットソン、ジョー・ケラー、ガレス・ケイリー、アンドレアス・ユングマイアー、ジャナルダン・アイエンガー、入江Mu也、ジョン・ヘバート、カウザー・ハッサン、フレッド・ハスル、ダン・ハリソン、ジョン・グリム、ローラン・グラード、スティーブン・ファーニス、福本At、藤田健、スティーブ・ディミグ、トーマスカラン、セルカン・シル、メリッサ・キャンベル、ピーター・バトラー、ロブ・ブレナン、ハーシュ・ボンドウェ、ブライアン・ビデュロック、ケイトリン・ベストラー、ジョン・バーガー、ロビー・ベネディク、スティーブン・バウケ、サンディープ・バラニ、ロニー・セラー

マーク・オールマンに特別な感謝をします. 彼は実際にマックス・バーストに関する彼の作品の共著者であるはずですが、技術的な理由でなんとか動き出しました. また、Lyndon OngとPhil Conradの貴重な意見と多くの貢献に感謝します. 

そして最後に、このドキュメントと、Alfred HoenesやRonnie Sellarsを含むコメントした人がいます.  

このドキュメントのコーディング、テスト、および更新プロセスに参加してくださったすべての人に感謝を申し上げます. 私が言えるのは、ありがとう！

ランドール・スチュワート-編集者 





























































付録A.明示的な輻輳通知 

ECN [RFC3168]は、データグラム損失以外の輻輳に気付く方法を詳述するIPへの提案された拡張について説明しています. これは、実装がSCTPに追加することを選択する場合があるオプション機能です. この付録では、実装者がこの機能を実装することを選択した場合に注意する必要がある小さな違いについて詳しく説明します. 一般に、[RFC3168]は次の例外を除いて従う必要があります. 

ネゴシエーション： 

[RFC3168] TCP接続のSYNおよびSYN-ACKステージ中のECNのネゴシエーションの詳細. SYNの送信者はTCPフラグに2ビットを設定し、SYN-ACKの送信者は1ビットのみを設定します. この背後にある理由は、双方が真のECN対応であることを保証することです. SCTPの場合、これは必要ありません. エンドポイントがECN対応であることを示すために、エンドポイントは、ECN用に予約されたTLVをINITまたはINIT ACKチャンクに追加する必要があります. このTLVにはパラメーターがないため、次の形式になります. 

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | パラメータタイプ= 32768 | パラメーターの長さ= 4 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+

ECNエコー： 

[RFC3168]は、ネットワークから到着したCongestion Experienced（CE）ビットを送信者に通知するために、受信者がTCP確認応答で送り返す特定のビットの詳細を示します. SCTPの場合、ECNEチャンクを含めることでこれと同じ指示が行われます. このチャンクには、1つのデータ要素、つまりCEビットでマークされたIPデータグラムに関連付けられた最も低いTSNが含まれ、次のようになります. 

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | チャンクタイプ= 12 | フラグ= 00000000 | チャンク長= 8 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ | 最低TSN番号| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+

注：ECNEは制御チャンクと見なされます.  







CWR： 

[RFC3168]は、輻輳ウィンドウが減少したことをピアに示すために、送信者が次の発信TCPセグメントのヘッダーで送信する特定のビットを詳述します. これはCWRビットと呼ばれます. SCTPの場合、CWRチャンクを含めることで同じ指示が行われます. このチャンクには、1つのデータ要素、つまりECNEチャンクで送信されたTSN番号が含まれます. この要素は、元々CEビットでマークされていたデータグラムの最小TSN番号を表します. 

0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- + | チャンクタイプ= 13 | フラグ= 00000000 | チャンク長= 8 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +- +-+-+-+-+-+-+ | 最低TSN番号| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+

注：CWRは制御チャンクと見なされます.  

付録B. CRC32cチェックサムの計算 

「反射値」は、マシンの通常のビット順序とは逆の値として定義します. 32ビットCRC（巡回冗長検査）はCRC32cの説明に従って計算され、多項式コード0x11EDC6F41（Castagnoli93）またはx ^ 32 + x ^ 28 + x ^ 27 + x ^ 26 + x ^ 25 + x ^ 23 +を使用しますx ^ 22 + x ^ 20 + x ^ 19 + x ^ 18 + x ^ 14 + x ^ 13 + x ^ 11 + x ^ 10 + x ^ 9 + x ^ 8 + x ^ 6 + x ^ 0. CRCは、トランスポートレベルの使用法を反映するように変更された、ETHERNET CRC [ITU32]と同様の手順を使用して計算されます. 

CRC計算では、多項式除算を使用します. メッセージのビット列Mは多項式M（X）に変換され、CRCは多項式演算を使用してM（X）から計算されます. 

リンク層でCRCが使用される場合、多項式はワイヤ上のビット順序から導出されます. 「ワイヤ上の」最初のビットは高次係数です. SCTPはトランスポートレベルのプロトコルであるため、実際のシリアルメディアのビット順序を知ることはできません. さらに、SCTPエンドポイント間のパス内の異なるリンクは、異なるリンクレベルのビット順序を使用する場合があります. 

したがって、CRC計算のためにSCTPトランスポートメッセージを多項式にマッピングするための規則を確立する必要があります. SCTPメッセージを多項式にマッピングするためのビット順序では、バイトが最初に最上位に取得されますが、各バイト内ではビットが最下位に最初に取得されます. メッセージの最初のバイトは、最も高い8つの係数を提供します. 各バイト内で、最下位SCTPビットはそのバイト内の最上位多項式係数を提供し、最上位SCTPビットはそのバイト内の最下位多項式係数です. （このビット順序は、「ミラー化」または「反射」と呼ばれることもあります[WILLIAMS93]. ）CRC多項式は、一貫したマッピングを使用して、SCTPトランスポートレベルバイト値に変換し直されます. 

SCTPトランスポートレベルCRC値は、次のように計算する必要があります.  

-CRC入力データは、0〜N-1の番号が付けられたバイトストリームに割り当てられます.  

-トランスポートレベルのバイトストリームは、多項式値にマップされます. 0〜N-1の番号が付けられたjバイトのNバイトPDUは、次数8N-1の多項式M（x）の係数と見なされます. バイトjのビット0は係数x ^（8（Nj）-8）です. バイトjのビット7は係数x ^（8（Nj）-1）です. 

-CRC剰余レジスタはすべて1で初期化され、CRCはx ^ 32で乗算し、CRC多項式で除算するアルゴリズムで計算されます.  

-多項式はx ^ 32で乗算され、生成多項式であるG（x）で除算され、31以下の次数の剰余R（x）が生成されます.  

-R（x）の係数は32ビットシーケンスと見なされます.  

-ビットシーケンスが補完されます. 結果はCRC多項式です. 

-CRC多項式は、SCTPトランスポートレベルバイトにマップされます. x ^ 31の係数はSCTPバイト0のビット7の値を与え、x ^ 24の係数はバイト0のビット0の値を与えます. x^ 7の係数はバイト3のビット7を与え、係数はx ^ 0からバイト3のビット0が得られます. 結果の4バイトのトランスポートレベルシーケンスは、32ビットSCTPチェックサム値です. 

実装に関する注：CRCに関する標準文書、教科書、およびベンダーの文献は、多くの場合、別の定式化に従います. この定式化では、ロングディビジョンアルゴリズムの残りの部分を保持するために使用されるレジスタは、すべて1ではなくゼロに初期化され、代わりに最初の32ビットメッセージの補完されます. この定式化で使用される長分割アルゴリズムは、2 ^ 32による初期乗算と長分割が1つの同時操作に結合されるように指定されています. このようなアルゴリズム、および64ビットより長いメッセージの場合、2つの仕様はまったく同じです. この同等性がこのドキュメントの意図です. 

SCTPの実装者は、両方の仕様が文献に記載されていることを警告されますが、長分割アルゴリズムに制限がない場合もあります. このドキュメントの定式化の選択は、非SCTPの使用を許可することです. 同じCRCアルゴリズムを使用して、64ビットより短いメッセージを保護できます. 

チェックサムを実行する前に、検証タグに対するアソシエーションを検証すると、ほとんどの場合、無効なタグが悪いチェックサムと同じアクションになるため、計算上の利点があります. この手法の例外は、INITおよびいくつかのSHUTDOWN-COMPLETE交換、および古いCOOKIE ECHOです. これらの特別な場合の交換は小さなパケットを表す必要があり、チェックサム計算の影響を最小限に抑えます. 

付録C. ICMP処理 

ICMPメッセージがSCTPエンドポイントによって受信されるたびに、次の手順に従って、レイヤ3によって提供される情報の適切な利用を保証する必要があります.  

ICMP1）実装は、typeフィールドが「Destination Unreachable」に設定されていないすべてのICMPv4メッセージを無視してもよい（MAY）.  

ICMP2）実装は、typeフィールドが「Destination Unreachable」、「Parameter Problem」、または「Packet Too Big」ではないすべてのICMPv6メッセージを無視してもよい（MAY）.  

ICMP3）実装は、コードが「Protocol Unreachable」または「Fragmentation Needed」を示さないICMPv4メッセージを無視してもよい（MAY）.  

ICMP4）コードが「認識されていない次のヘッダータイプが検出された」でない場合、実装はタイプ「パラメータの問題」のすべてのICMPv6メッセージを無視してもよい（MAY）.  

ICMP5）実装はICMPメッセージのペイロード（v4またはv6）を使用して、ICMPが応答しているメッセージを送信したアソシエーションを見つけなければなりません（MUST）. 関連付けが見つからない場合、実装はICMPメッセージを無視する必要があります. 

ICMP6）実装は、ICMPメッセージに含まれる検証タグがピアの検証タグと一致することを検証しなければなりません. 検証タグが0ではなく、一致しない場合は、ICMPメッセージを破棄します. 0で、ICMPメッセージに十分なバイトが含まれていて、チャンクタイプがINITチャンクであり、開始タグが



ピア、ICMP7に進みます. ICMPメッセージが短すぎる場合、またはチャンクタイプまたは開始タグが一致しない場合は、静かにパケットを破棄します. 

ICMP7）ICMPメッセージがv6 "Packet Too Big"またはv4 "Fragmentation Needed"の場合、実装はこの情報をPATH MTUディスカバリーの定義に従って処理する場合があります.  

ICMP8）ICMPコードが「Unrecognized Next Header Type Encountered」または「Protocol Unreachable」である場合、実装はINITチャンクを含まない場合、Tビットが設定されたこのメッセージをアボートとして扱わなければなりません. INITチャンクが含まれていて、関連付けがCOOKIE-WAIT状態にある場合、ABORTのようにICMPメッセージを処理します. 

ICMP9）ICMPv6コードが「Destination Unreachable」の場合、実装は宛先を到達不能状態にマークするか、またはパスエラーカウンターをインクリメントすることができます.  

これらの手順は[RFC1122]とポート到達不能メッセージの処理要件および実装が「プロトコル到達不能」メッセージに応答してアソシエーションを中止しなければならない要件とは異なることに注意してください. 実装はポート到達不能ではなくABORTを送信するため、ポート到達不能メッセージは処理されません. 「プロトコル到達不能」メッセージのより厳密な処理は、SCTPをサポートしないホストのセキュリティ上の懸念によるものです. 

次の非規範的なサンプルコードは、オープンソースCRCジェネレーター[WILLIAMS93]から取得され、「ミラーリング」技術を使用して、それぞれ32ビット幅の256エントリのSCTP CRC32cのルックアップテーブルを生成します. ソフトウェアテーブルルックアップCRCのように特に低速でも高速でもありませんが、ビッグエンディアンとリトルエンディアンの両方のCPUで動作し、同じ（ホスト順）ルックアップテーブルを使用し、定義済みのntohlのみを使用するという利点があります（）およびhtonl（）操作. コードは[WILLIAMS93]から多少変更され、ビッグエンディアンとリトルエンディアンのアーキテクチャ間の移植性を確保しています. （ターゲットアーキテクチャのバイトエンディアンがリトルエンディアンであることがわかっている場合、最後のビット反転とバイト反転のステップを1つの操作にまとめることができます. ）

/ **************************************************** ************ / / *ロスウィリアムズテーブルジェネレーターの定義は* / / *になります：TB_WIDTH = 4、TB_POLLY = 0x1EDC6F41、TB_REVER = TRUE * / / *ウィリアムズ氏の直接計算用コードは設定を使用します* / / * cm_width = 32、cm_poly = 0x1EDC6F41、cm_init = 0xFFFFFFFF、* / / * cm_refin = TRUE、cm_refot = TRUE、cm_xorort = 0x00000000 * / / ************ ************************************************* / / * crcテーブルファイルの例* / #ifndef __crc32cr_table_h__ #define __crc32cr_table_h__ 

#define CRC32C_POLY 0x1EDC6F41 #define CRC32C（c、d）（c =（c >> 8）^ crc_c [（c ^（d））＆0xFF]） 

unsigned long型crc_c [256] = {0x00000000L、0xF26B8303L、0xE13B70F7L、0x1350F3F4L、0xC79A971FL、0x35F1141CL、0x26A1E7E8L、0xD4CA64EBL、0x8AD958CFL、0x78B2DBCCL、0x6BE22838L、0x9989AB3BL、0x4D43CFD0L、0xBF284CD3L、0xAC78BF27L、0x5E133C24L、0x105EC76FL、0xE235446CL、0xF165B798L、0x030E349BL、0xD7C45070L、 0x25AFD373L、0x36FF2087L、0xC494A384L、0x9A879FA0L、0x68EC1CA3L、0x7BBCEF57L、0x89D76C54L、0x5D1D08BFL、0xAF768BBCL、0xBC267848L、0x4E4DFB4BL、0x20BD8EDEL、0xD2D60DDDL、0xC186FE29L、0x33ED7D2AL、0xE72719C1L、0x154C9AC2L、0x061C6936L、0xF477EA35L、0xAA64D611L、0x580F5512L、0x4B5FA6E6L、0xB93425E5L、0x6DFE410EL、0x9F95C20DL、 0x8CC531F9L、0x7EAEB2FAL、0x30E349B1L、0xC288CAB2L、0xD1D83946L、0x23B3BA45L、

0xF779DEAEL、0x05125DADL、0x1642AE59L、0xE4292D5AL、0xBA3A117EL、0x4851927DL、0x5B016189L、0xA96AE28AL、0x7DA08661L、0x8FCB0562L、0x9C9BF696L、0x6EF07595L、0x417B1DBCL、0xB3109EBFL、0xA0406D4BL、0x522BEE48L、0x86E18AA3L、0x748A09A0L、0x67DAFA54L、0x95B17957L、0xCBA24573L、0x39C9C670L、0x2A993584L、0xD8F2B687L、0x0C38D26CL、 0xFE53516FL、0xED03A29BL、0x1F682198L、0x5125DAD3L、0xA34E59D0L、0xB01EAA24L、0x42752927L、0x96BF4DCCL、0x64D4CECFL、0x77843D3BL、0x85EFBE38L、0xDBFC821CL、0x2997011FL、0x3AC7F2EBL、0xC8AC71E8L、0x1C661503L、0xEE0D9600L、0xFD5D65F4L、0x0F36E6F7L、0x61C69362L、0x93AD1061L、0x80FDE395L、0x72966096L、0xA65C047DL、0x5437877EL、 0x4767748AL、0xB50CF789L、0xEB1FCBADL、0x197448AEL、0x0A24BB5AL、0xF84F3859L、0x2C855CB2L、0xDEEEDFB1L、0xCDBE2C45L、0x3FD5AF46L0C、A0x5739B3E5L、0xA55230E6L、0xFB410CC2L、0x092A8FC1L、0x1A7A7C35L、0xE811FF36L、0x3CDB9BDDL、0xCEB018DEL、0xDDE0EB2AL、0x2F8B6829L、0x82F63B78L、0x709DB87BL、0x63CD4B8FL、0x91A6C88CL、0x456CAC67L、0xB7072F64L、0xA457DC90L、0x563C5F93L、0x082F63B7L、0xFA44E0B4L、0xE9141340L、0x1B7F9043L、0xCFB5F4A8L、0x3DDE77ABL、0x2E8E845FL、 0xDCE5075CL、0x92A8FC17L、0x60C37F14L、0x73938CE0L、0x81F80FE3L、0x55326B08L、0xA759E80BL、0xB4091BFFL、0x466298FCL、0x1871A4D8L、0xEA1A27DBL、0xF94AD42FL、0x0B21572CL、0xDFEB33C7L、0x2D80B0C4L、0x3ED04330L、0xCCBBC033L、0xA24BB5A6L、0x502036A5L、0x4370C551L、0xB11B4652L、0x65D122B9L、0x97BAA1BAL、0x84EA524EL、0x7681D14DL、 0x2892ED69L、0xDAF96E6AL、0xC9A99D9EL、0x3BC21E9DL、0xEF087A76L、0x1D63F975L、0x0E330A81L、0xFC588982L、0xB21572C9L、0x407E10、0x407EF1CAL、0x532E023EL、0x407E1CAL、0x532E023EL、0x407E1CAL、0x532E023EL、0x407E1CAL、0x532E023EL、0x407E1CAL、0x532E023EL、0x407E1CAL、0x532E023EL、0x407E1CAL、0x532E023EL、0x407E1CAL、0x532E023EL、0x407E1CAL、0x532E023EL、0x407E0CAL0x38CC2A06L、0xCAA7A905L、0xD9F75AF1L、0x2B9CD9F2L、0xFF56BD19L、0x0D3D3E1AL、0x1E6DCDEEL、0xEC064EEDL、0xC38D26C4L、0x31E6A5C7L、0x22B65633L、0xD0DDD530L、0x0417B1DBL、0xF67C32D8L、0xE52CC12CL、0x1747422FL、0x49547E0BL、0xBB3FFD08L、0xA86F0EFCL、0x5A04​​8DFFL、0x8ECEE914L、0x7CA56A17L、0x6FF599E3L、0x9D9E1AE0L、0xD3D3E1ABL、 0x21B862A8L、0x32E8915CL、0xC083125FL、0x144976B4L、0xE622F5B7L、0xF5720643L、0x07198540L、0x590AB964L、0xAB613A67L、0xB831C993L、0x4A5A4A90L、0x9E902E7BL、0x6CFBAD78L、0x7FAB5E8CL、0x8DC0DD8FL、0xE330A81AL、0x115B2B19L、0x020BD8EDL、0xF0605BEEL、0x24AA3F05L、0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、 0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、0x1E6DCDEEL、0xEC064EEDL、0xC38D26C4L、0x31E6A5C7L、0x22B65633L、0xD0DDD530L、0x0417B1DBL、0xF67C32D8L、0xE52CC12CL、0x1747422FL、0x49547E0BL、0xBB3FFD08L、0xA86F0EFCL、0x5A04​​8DFFL、0x8ECEE914L、0x7CA56A17L、0x6FF599E3L、0x9D9E1AE0L、0xD3D3E1ABL、0x21B862A8L、0x32E8915CL、0xC083125FL、0x144976B4L、0xE622F5B7L、0xF5720643L、 0x07198540L、0x590AB964L、0xAB613A67L、0xB831C993L、0x4A5A4A90L、0x9E902E7BL、0x6CFBAD78L、0x7FAB5E8CL、0x8DC0DD8FL、0xE330A81AL、0x115B2B19L、0x020BD8EDL、0xF0605BEEL、0x24AA3F05L、0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、 0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、0x1E6DCDEEL、0xEC064EEDL、0xC38D26C4L、0x31E6A5C7L、0x22B65633L、0xD0DDD530L、0x0417B1DBL、0xF67C32D8L、0xE52CC12CL、0x1747422FL、0x49547E0BL、0xBB3FFD08L、0xA86F0EFCL、0x5A04​​8DFFL、0x8ECEE914L、0x7CA56A17L、0x6FF599E3L、0x9D9E1AE0L、0xD3D3E1ABL、0x21B862A8L、0x32E8915CL、0xC083125FL、0x144976B4L、0xE622F5B7L、0xF5720643L、 0x07198540L、0x590AB964L、0xAB613A67L、0xB831C993L、0x4A5A4A90L、0x9E902E7BL、0x6CFBAD78L、0x7FAB5E8CL、0x8DC0DD8FL、0xE330A81AL、0x115B2B19L、0x020BD8EDL、0xF0605BEEL、0x24AA3F05L、0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、 0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、0xA86F0EFCL、0x5A04​​8DFFL、0x8ECEE914L、0x7CA56A17L、0x6FF599E3L、0x9D9E1AE0L、0xD3D3E1ABL、0x21B862A8L、0x32E8915CL、0xC083125FL、0x144976B4L、0xE622F5B7L、0xF5720643L、0x07198540L、0x590AB964L、0xAB613A67L、0xB831C993L、0x4A5A4A90L、0x9E902E7BL、0x6CFBAD78L、0x7FAB5E8CL、0x8DC0DD8FL、0xE330A81AL、0x115B2B19L、0x020BD8EDL、 0xF0605BEEL、0x24AA3F05L、0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、0xA86F0EFCL、0x5A04​​8DFFL、0x8ECEE914L、0x7CA56A17L、0x6FF599E3L、0x9D9E1AE0L、0xD3D3E1ABL、0x21B862A8L、0x32E8915CL、0xC083125FL、0x144976B4L、0xE622F5B7L、0xF5720643L、0x07198540L、0x590AB964L、0xAB613A67L、0xB831C993L、0x4A5A4A90L、0x9E902E7BL、0x6CFBAD78L、0x7FAB5E8CL、0x8DC0DD8FL、0xE330A81AL、0x115B2B19L、0x020BD8EDL、 0xF0605BEEL、0x24AA3F05L、0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、0x020BD8EDL、0xF0605BEEL、0x24AA3F05L、0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、0x020BD8EDL、0xF0605BEEL、0x24AA3F05L、0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、

0x34F4F86AL、0xC69F7B69L、0xD5CF889DL、0x27A40B9EL、0x79B737BAL、0x8BDCB4B9L、0x988C474DL、0x6AE7C44EL、0xBE2DA0A5L、0x4C4623A6L、0x5F16D05} 

#endif 

/ *テーブル構築ルーチンの例* / 

#include <stdio.h> #include <stdlib.h> 

#define OUTPUT_FILE "crc32cr.h" #define CRC32C_POLY 0x1EDC6F41L FILE * tf; unsigned long reflect_32（unsigned long b）{int i; 符号なしlong rw = 0L;

for（i = 0; i <32; i ++）{if（b＆1）rw | = 1 <<（31-i）; b >> = 1; } return（rw）; }

unsigned long build_crc_table（int index）{int i; 符号なしlong rb;

rb = reflect_32（インデックス）; 

for（i = 0; i <8; i ++）{if（rb＆0x80000000L）rb =（rb << 1）^ CRC32C_POLY; それ以外の場合rb << = 1; } return（reflect_32（rb））; }

main（）{int i; 

printf（ "\ nCRC-32cテーブルファイル<％s> \ n"の生成、OUTPUT_FILE）; if（（tf = fopen（OUTPUT_FILE、 "w"））== NULL）{printf（ "％s \ nを開くことができません"、OUTPUT_FILE）; exit（1）; } fprintf（tf、 "#ifndef __crc32cr_table_h __ \ n"）; fprintf（tf、 "#define __crc32cr_table_h __ \ n \ n"）; fprintf（tf、 "#define CRC32C_POLY 0x％08lX \ n"、CRC32C_POLY）; fprintf（tf、 "#define CRC32C（c、d）（c =（c >> 8）^ crc_c [（c ^（d））＆0xFF]）\ n"）; fprintf（tf、 "\ nunsigned long crc_c [256] = \ n {\ n"）; for（i = 0; i <256; i ++）{fprintf（tf、 "0x％08lXL、"、build_crc_table（i））; if（（i＆3）== 3）fprintf（tf、 "\ n"）; } fprintf（tf、 "}; \ n \ n＃endif \ n"）;

if（fclose（tf）！= 0）printf（ "<％s>を閉じることができません. " OUTPUT_FILE）; else printf（ "\ nCRC-32cテーブルは<％s>. \ n"、OUTPUT_FILEに書き込まれました）; }

/ * crc挿入の例* / 

#include "crc32cr.h" 

unsigned long generate_crc32c（unsigned char * buffer、unsigned int length）{unsigned int i; 符号なしlong crc32 =〜0L; 符号なしの長い結果. unsigned char byte0、byte1、byte2、byte3;

for（i = 0; i <長さ; i ++）{CRC32C（crc32、buffer [i]）; }

結果=〜crc32; 

/ *結果は、否定された多項式剰余を保持します. *テーブルとアルゴリズムが「反映」されているため[williams95]. *つまり、結果は、メッセージを多項式にマッピングし、ホストビット次数多項式*剰余を計算し、最終否定を実行し、エンドツーエンド*ビット反転を実行した場合と同じ値を持ちます. * 32ビットのビット反転は、4つのインプレースと同じであることに注意してください. * 8ビットの反転とそれに続くエンドツーエンドのバイトスワップ. *つまり、各ビットのバイトは正しい順序になっていますが、バイトはバイトスワップされています. そこで、明示的に*バイトスワップを行います. リトルエンディアンのマシンでは、このバイトスワップと最後のntohlはキャンセルされ、省略できます. * /

byte0 =結果＆0xff; byte1 =（結果>> 8）＆0xff; byte2 =（結果>> 16）＆0xff; byte3 =（結果>> 24）＆0xff; crc32 =（（byte0 << 24）|（byte1 << 16）|（byte2 << 8）| byte3）; return（crc32）; }

int insert_crc32（unsigned char * buffer、unsigned int length）{SCTP_message * message; 符号なしの長いcrc32; メッセージ=（SCTP_message *）バッファー; message-> common_header.checksum = 0L; crc32 = generate_crc32c（buffer、length）; / *およびメッセージに挿入* / message-> common_header.checksum = htonl（crc32）; 1を返します. }

int validate_crc32（unsigned char * buffer、unsigned int length）{SCTP_message * message; 符号なしint i; unsigned long original_crc32; 符号なしlong crc32 =〜0L;

/ *保存およびゼロチェックサム* / message =（SCTP_message *）buffer; original_crc32 = ntohl（message-> common_header.checksum）; message-> common_header.checksum = 0L; crc32 = generate_crc32c（buffer、length）; return（（ori​​ginal_crc32 == crc32）？1：-1）; }

参照資料 

規範的参考文献 

[ITU32]「ITU-T勧告V.42、「非同期から同期への変換を使用するDCEのエラー修正手順」. 」、ITU-Tセクション8.1.1.6.2.  

[RFC0768]ポステル、J. 、「ユーザーデータグラムプロトコル」、STD 6、RFC 768、1980年8月.  

[RFC0793]ポステル、J. 、「伝送制御プロトコル」、STD 7、RFC 793、1981年9月.  

[RFC1122]ブレーデン、R. 、エド、「インターネットホストの要件-通信層」、STD 3、RFC 1122、1989年10月.  

[RFC1123]ブレーデン、R. 、エド、「インターネットホストの要件-アプリケーションとサポート」、STD 3、RFC 1123、1989年10月.  

[RFC1191] Mogul、J. およびS. Deering、「Path MTU discovery」、RFC 1191、1990年11月.  

[RFC1981] McCann、J.、Deering、S. 、およびJ. Mogul、「IPバージョン6のパスMTUディスカバリ」、RFC 1981、1996年8月.  

[RFC1982] Elz、R. およびR. Bush、「シリアル番号算術」、RFC 1982、1996年8月.  

[RFC2119] Bradner、S.、「要求レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月.  

[RFC2434] Narten、T. 、およびH. Alvestrand、「RFCでIANA考慮事項セクションを記述するためのガイドライン」、BCP 26、RFC 2434、1998年10月.  

[RFC2460] Deering、S. およびR. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、RFC 2460、1998年12月.  

[RFC2581] Allman、M.、Paxson、V. 、およびW. Stevens、「TCP Congestion Control」、RFC 2581、1999年4月.  

[RFC3873]牧師、J. およびM. Belinchon、「ストリーム制御伝送プロトコル（SCTP）管理情報ベース（MIB）」、RFC 3873、2004年9月.  

[RFC4291] Hinden、R. およびS. Deering、「IPバージョン6アドレス指定アーキテクチャ」、RFC 4291、2006年2月. [RFC4301] Kent、S. およびK. Seo、「インターネットプロトコルのセキュリティアーキテクチャ」、RFC 4301、 2005年12月.  

[RFC4303]ケント、S. 、「IPカプセル化セキュリティペイロード（ESP）」、RFC 4303、2005年12月.  

[RFC4306] Kaufman、C.、Ed. 、「インターネットキーエクスチェンジ（IKEv2）プロトコル」、RFC 4306、2005年12月.  

[RFC4821] Mathis、M. 、およびJ. Heffner、「パケット化層パスMTUディスカバリー」、RFC 4821、2007年3月.  

参考資料 

[FALL96] Fall、K. およびS. Floyd、「タホ、リノ、およびSACK TCPのシミュレーションベースの比較」、SIGCOMM'99 V. 26 N. 3 pp 5- 21、1996年7月.  

[SAVAGE99]サベージ、S. 、カードウェル、N. 、ウェザロール、D. 、およびT.アンダーソン、「不正な受信機によるTCP輻輳制御」、ACM Computer Communications Review 29（5）、10月 

[ALLMAN99] Allman、M. 、およびV. Paxson、「エンドツーエンドネットワークパスプロパティの推定」、SIGCOMM'99、1999年.  

[WILLIAMS93] Williams、R. 、「CRCエラー検出アルゴリズムの苦痛のないガイド」、インターネット出版物、http：//www.geocities.com/SiliconValley/Pines/ 8659 / crc.htm、1993年8月.  

[RFC0813]クラーク、D. 、「TCPのウィンドウおよび確認戦略」、RFC 813、1982年7月.  

[RFC1858] Ziemba、G.、Reed、D. 、およびP. Traina、「IPフラグメントフィルタリングのセキュリティに関する考慮事項」、RFC 1858、1995年10月.  

[RFC2104] Krawczyk、H.、Bellare、M. 、およびR. Canetti、「HMAC：メッセージ認証のためのキー付きハッシュ」、RFC 2104、1997年2月.  

[RFC2196] Fraser、B. 、「サイトセキュリティハンドブック」、FYI 8、RFC 2196、1997年9月.  

[RFC2522]カーン、P. およびW.シンプソン、「Photuris：セッションキー管理プロトコル」、RFC 2522、1999年3月.  

[RFC2960] Stewart、R.、Xie、Q.、Morneault、K.、Sharp、C.、Schwarzbauer、H.、Taylor、T.、Rytina、I.、Kalla、M.、Zhang、L. 、およびV . Paxson、「ストリーム制御伝送プロトコル」、RFC 2960、2000年10月.  

[RFC3309]ストーン、J. 、スチュワート、R. 、およびD.オーティス、「ストリーム制御伝送プロトコル（SCTP）チェックサム変更」、RFC 3309、2002年9月.  

[RFC3168]ラマクリシュナン、K. 、フロイド、S. 、およびD.ブラック、「IPへの明示的な輻輳通知（ECN）の追加」、RFC 3168、2001年9月.  

[RFC4086] Eastlake、D.、3rd、Schiller、J. 、およびS. Crocker、「セキュリティのランダム要件」、BCP 106、RFC 4086、2005年6月.  

[RFC4460]スチュワート、R. 、アリアス-ロドリゲス、I. 、プーン、K. 、カロ、A. 、およびM.テクセン、「Stream Control Transmission Protocol（SCTP）Specification Errata and Issues」、RFC 4460、2006年4月 

[RFC4895] Tuexen、M. 、スチュワート、R. 、レイ、P. 、およびE. Rescorla、「ストリーム制御伝送プロトコル（SCTP）の認証済みチャンク」、RFC 4895、2007年8月 

編集者の住所 

Randall R. Stewart 4875 Forest Drive Suite 200 Columbia、SC 29206 US 

電子メール：rrs@cisco.com 

























完全な著作権表示 

著作権（C）IETFトラスト（2007）.  

このドキュメントは、BCP 78に含まれる権利、ライセンス、制限の対象となります. そこに記載されている場合を除き、著者はすべての権利を保持します.  

この文書とここに含まれる情報は「現状のまま」で提供され、寄稿者、彼または彼女の代表者または組織（もしあれば）、インターネット協会、IETFトラストおよびインターネットエンジニアリングタスクフォース免責明示または黙示を問わず、ここに記載された情報の使用が商品性または特定の目的への適合性の黙示的な保証を侵害しないという保証を含む保証.  

知的財産 

IETFは、このドキュメントに記載されている技術の実装または使用に関連すると主張される可能性のある知的財産権またはその他の権利の有効性または範囲、またはそのような権利の下でのライセンスの有無に関して立場を取りません利用可能 また、そのような権利を特定するための独立した努力を行ったことを表明するものでもありません. RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています. 

IETF事務局に行われたIPR開示のコピーおよび利用可能になるライセンスの保証、またはこの仕様の実装者またはユーザーによる一般的なライセンスまたはそのような所有権の使用許可の取得を試みた結果を取得できます.  IETFオンラインIPRリポジトリ（http://www.ietf.org/ipr）から.  

IETFは、この標準の実装に必要な技術を対象とする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を喚起するために、利害関係者を招待します. IETF（ietf-ipr@ietf.org）に情報を送信してください. 